(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs'), require('@angular/core/testing'), require('@angular/platform-browser'), require('@testing-library/dom'), require('@angular/platform-browser-dynamic/testing'), require('jquery'), require('@angular/platform-browser/animations'), require('@angular/router'), require('rxjs/operators'), require('@angular/router/testing'), require('@angular/common/http'), require('@angular/common/http/testing')) :
    typeof define === 'function' && define.amd ? define('@ngneat/spectator', ['exports', '@angular/core', 'rxjs', '@angular/core/testing', '@angular/platform-browser', '@testing-library/dom', '@angular/platform-browser-dynamic/testing', 'jquery', '@angular/platform-browser/animations', '@angular/router', 'rxjs/operators', '@angular/router/testing', '@angular/common/http', '@angular/common/http/testing'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.ngneat = global.ngneat || {}, global.ngneat.spectator = {}), global.ng.core, global.rxjs, global.ng.core.testing, global.ng.platformBrowser, global.dom, global.ng.platformBrowserDynamic.testing, global.$, global.ng.platformBrowser.animations, global.ng.router, global.rxjs.operators, global.ng.router.testing, global.ng.common.http, global.ng.common.http.testing));
}(this, (function (exports, core, rxjs, testing, platformBrowser, dom, testing$1, $, animations, router, operators, testing$2, http, testing$3) { 'use strict';

    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

    var $__default = /*#__PURE__*/_interopDefaultLegacy($);

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    ;
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }
    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    var DOMSelector = /** @class */ (function () {
        // Wrap selector functions in a class to make reflection easier in getChild
        function DOMSelector(execute) {
            this.execute = execute;
        }
        return DOMSelector;
    }());
    var byLabel = function (matcher, options) { return new DOMSelector(function (el) { return dom.queries.queryAllByLabelText(el, matcher, options); }); };
    var byPlaceholder = function (matcher, options) { return new DOMSelector(function (el) { return dom.queries.queryAllByPlaceholderText(el, matcher, options); }); };
    var byText = function (matcher, options) { return new DOMSelector(function (el) { return dom.queries.queryAllByText(el, matcher, options); }); };
    var byTextContent = function (matcher, options) {
        var textContentMatcher;
        var normalizer = (options === null || options === void 0 ? void 0 : options.normalizer) || dom.getDefaultNormalizer(options);
        var getTextContent = function (elem) { var _a; return normalizer((_a = elem.textContent) !== null && _a !== void 0 ? _a : ''); };
        if (typeof matcher === 'string') {
            textContentMatcher = function (_, elem) {
                if ((options === null || options === void 0 ? void 0 : options.exact) === false) {
                    return (getTextContent(elem)
                        .toLowerCase()
                        .indexOf(matcher.toLowerCase()) >= 0);
                }
                return getTextContent(elem) === matcher;
            };
        }
        else if (matcher instanceof RegExp) {
            textContentMatcher = function (_, elem) { return matcher.test(getTextContent(elem)); };
        }
        else {
            textContentMatcher = function (_, elem) { return matcher(getTextContent(elem), elem); };
        }
        return new DOMSelector(function (el) { return dom.queries.queryAllByText(el, textContentMatcher, options); });
    };
    var byAltText = function (matcher, options) { return new DOMSelector(function (el) { return dom.queries.queryAllByAltText(el, matcher, options); }); };
    var byTitle = function (matcher, options) { return new DOMSelector(function (el) { return dom.queries.queryAllByTitle(el, matcher, options); }); };
    var byTestId = function (matcher, options) { return new DOMSelector(function (el) { return dom.queries.queryAllByTestId(el, matcher, options); }); };
    var byValue = function (matcher, options) { return new DOMSelector(function (el) { return dom.queries.queryAllByDisplayValue(el, matcher, options); }); };
    var byRole = function (matcher, options) { return new DOMSelector(function (el) { return dom.queries.queryAllByRole(el, matcher, options); }); };

    function doesServiceImplementsOnDestroy(testedService) {
        return 'ngOnDestroy' in testedService && typeof testedService['ngOnDestroy'] === 'function';
    }
    function isString(value) {
        return typeof value === 'string';
    }
    function isNumber(value) {
        return typeof value === 'number';
    }
    function isType(v) {
        return typeof v === 'function';
    }
    function isHTMLOptionElementArray(value) {
        return Array.isArray(value) && !!value.length && value.every(function (item) { return item instanceof HTMLOptionElement; });
    }
    function isObject(v) {
        return v && typeof v === 'object';
    }

    function getChildren(debugElementRoot) {
        return function (directiveOrSelector, options) {
            if (options === void 0) { options = { root: false, read: undefined }; }
            if (directiveOrSelector instanceof DOMSelector) {
                return directiveOrSelector.execute(debugElementRoot.nativeElement);
            }
            var debugElements = debugElementRoot.queryAll(isString(directiveOrSelector) ? platformBrowser.By.css(directiveOrSelector) : platformBrowser.By.directive(directiveOrSelector));
            if (options.read) {
                return debugElements.map(function (debug) { return debug.injector.get(options.read); });
            }
            if (isString(directiveOrSelector)) {
                return debugElements.map(function (debug) { return debug.nativeElement; });
            }
            return debugElements.map(function (debug) { return debug.injector.get(directiveOrSelector); });
        };
    }
    function setProps(instance, keyOrKeyValues, value, firstChange) {
        if (firstChange === void 0) { firstChange = true; }
        var _a;
        var changes = {};
        var update = function (key, newValue) {
            if (instance[key] !== newValue) {
                changes[key] = new core.SimpleChange(instance[key], newValue, firstChange);
            }
            instance[key] = newValue;
        };
        if (isString(keyOrKeyValues)) {
            update(keyOrKeyValues, value);
        }
        else {
            // tslint:disable-next-line:forin
            for (var p in keyOrKeyValues) {
                update(p, keyOrKeyValues[p]);
            }
        }
        if (Object.keys(changes).length) {
            // tslint:disable-next-line:no-life-cycle-call
            (_a = instance.ngOnChanges) === null || _a === void 0 ? void 0 : _a.call(instance, changes);
        }
        return instance;
    }

    var parseKeyOptions = function (keyOrKeyCode) {
        if (isNumber(keyOrKeyCode) && keyOrKeyCode) {
            return { key: false, keyCode: keyOrKeyCode, modifiers: {} };
        }
        if (isString(keyOrKeyCode) && keyOrKeyCode) {
            return parseKey(keyOrKeyCode);
        }
        if (isObject(keyOrKeyCode)) {
            var parsedKey = parseKey(keyOrKeyCode.key);
            return Object.assign(Object.assign({}, parsedKey), { keyCode: keyOrKeyCode.keyCode });
        }
        throw new Error('keyboard.pressKey() requires a valid key or keyCode');
    };
    var parseKey = function (keyStr) {
        if (keyStr.indexOf('.') < 0 || '.' === keyStr) {
            return { key: keyStr, keyCode: false, modifiers: {} };
        }
        var keyParts = keyStr.split('.');
        var key = keyParts.pop();
        var modifiers = keyParts.reduce(function (mods, part) {
            switch (part) {
                case 'control':
                case 'ctrl':
                    mods.control = true;
                    return mods;
                case 'shift':
                    mods.shift = true;
                    return mods;
                case 'alt':
                    mods.alt = true;
                    return mods;
                case 'meta':
                case 'cmd':
                case 'win':
                    mods.meta = true;
                    return mods;
                default:
                    throw new Error("invalid key modifier: " + (part ? part : 'undefined') + ", keyStr: " + keyStr);
            }
        }, { alt: false, control: false, shift: false, meta: false });
        return { key: key, keyCode: false, modifiers: modifiers };
    };
    var ɵ0 = parseKey;

    /**
     * Credit - Angular Material
     */
    /** Creates a browser MouseEvent with the specified options. */
    function createMouseEvent(type, x, y, button) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        if (button === void 0) { button = 0; }
        var event = document.createEvent('MouseEvent');
        event.initMouseEvent(type, true, false, window, 0, x, y, x, y, false, false, false, false, button, null);
        // `initMouseEvent` doesn't allow us to pass the `buttons` and
        // defaults it to 0 which looks like a fake event.
        Object.defineProperty(event, 'buttons', { get: function () { return 1; } });
        return event;
    }
    /**
     * Creates a browser TouchEvent with the specified pointer coordinates.
     */
    function createTouchEvent(type, pageX, pageY) {
        if (pageX === void 0) { pageX = 0; }
        if (pageY === void 0) { pageY = 0; }
        // In favor of creating events that work for most of the browsers, the event is created
        // as a basic UI Event. The necessary details for the event will be set manually.
        var event = new UIEvent(type, {
            bubbles: true,
            cancelable: true,
            view: window,
            detail: 0
        });
        // Most of the browsers don't have a "initTouchEvent" method that can be used to define
        // the touch details.
        Object.defineProperties(event, {
            touches: { value: [{ pageX: pageX, pageY: pageY }] }
        });
        return event;
    }
    /** Dispatches a keydown event from an element. */
    function createKeyboardEvent(type, keyOrKeyCode, target) {
        var _a = parseKeyOptions(keyOrKeyCode), key = _a.key, keyCode = _a.keyCode, modifiers = _a.modifiers;
        var event = document.createEvent('KeyboardEvent');
        var originalPreventDefault = event.preventDefault;
        // Firefox does not support `initKeyboardEvent`, but supports `initKeyEvent`.
        if (event.initKeyEvent) {
            event.initKeyEvent(type, true, true, window, modifiers.control, modifiers.alt, modifiers.shift, modifiers.meta, keyCode);
        }
        else {
            // `initKeyboardEvent` expects to receive modifiers as a whitespace-delimited string
            // See https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/initKeyboardEvent
            var modifiersStr = (modifiers.control
                ? 'Control '
                : '' + modifiers.alt
                    ? 'Alt '
                    : '' + modifiers.shift
                        ? 'Shift '
                        : '' + modifiers.meta
                            ? 'Meta'
                            : '').trim();
            event.initKeyboardEvent(type, true /* canBubble */, true /* cancelable */, window /* view */, 0 /* char */, key /* key */, 0 /* location */, modifiersStr /* modifiersList */, false /* repeat */);
        }
        // Webkit Browsers don't set the keyCode when calling the init function.
        // See related bug https://bugs.webkit.org/show_bug.cgi?id=16735
        Object.defineProperties(event, {
            keyCode: { get: function () { return keyCode; } },
            key: { get: function () { return key; } },
            target: { get: function () { return target; } },
            altKey: { get: function () { return !!modifiers.alt; } },
            ctrlKey: { get: function () { return !!modifiers.control; } },
            shiftKey: { get: function () { return !!modifiers.shift; } },
            metaKey: { get: function () { return !!modifiers.meta; } }
        });
        // IE won't set `defaultPrevented` on synthetic events so we need to do it manually.
        // tslint:disable-next-line
        event.preventDefault = function () {
            Object.defineProperty(event, 'defaultPrevented', { configurable: true, get: function () { return true; } });
            return originalPreventDefault.apply(this, arguments);
        };
        return event;
    }
    /** Creates a fake event object with any desired event type. */
    function createFakeEvent(type, canBubble, cancelable) {
        if (canBubble === void 0) { canBubble = false; }
        if (cancelable === void 0) { cancelable = true; }
        var event = document.createEvent('Event');
        event.initEvent(type, canBubble, cancelable);
        return event;
    }

    /**
     * Credit - Angular Material
     */
    /**
     * Utility to dispatch any event on a Node.
     *
     * @publicApi
     */
    function dispatchEvent(node, event) {
        node.dispatchEvent(event);
        return event;
    }
    /**
     * Shorthand to dispatch a fake event on a specified node.
     *
     * dispatchFakeEvent(element, 'mousedown');
     *
     * @publicApi
     */
    function dispatchFakeEvent(node, type, canBubble) {
        return dispatchEvent(node, createFakeEvent(type, canBubble));
    }
    /**
     * Shorthand to dispatch a keyboard event with a specified key.
     *
     *  dispatchKeyboardEvent(calendarBodyEl, 'keydown', 'LEFT_ARROW');
     *
     *  @publicApi
     */
    function dispatchKeyboardEvent(node, type, keyOrKeyCode, target) {
        return dispatchEvent(node, createKeyboardEvent(type, keyOrKeyCode, target));
    }
    /**
     * Shorthand to dispatch a mouse event on the specified coordinates.
     *
     *  dispatchMouseEvent(rippleTarget, 'mousedown', 50, 75);
     *  dispatchMouseEvent(rippleTarget, 'mouseup');
     *
     *  @publicApi
     */
    function dispatchMouseEvent(node, type, x, y, event) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        if (event === void 0) { event = createMouseEvent(type, x, y); }
        return dispatchEvent(node, event);
    }
    /**
     * Shorthand to dispatch a touch event on the specified coordinates.
     *
     * dispatchTouchEvent(rippleTarget, 'touchstart');
     *
     * @publicApi
     */
    function dispatchTouchEvent(node, type, x, y) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        return dispatchEvent(node, createTouchEvent(type, x, y));
    }

    /**
     * Patches an elements focus and blur methods to emit events consistently and predictably.
     * This is necessary, because some browsers, like IE11, will call the focus handlers asynchronously,
     * while others won't fire them at all if the browser window is not focused.
     *
     * patchElementFocus(triggerEl);
     */
    function patchElementFocus(element) {
        element.focus = function () { return dispatchFakeEvent(element, 'focus'); };
        element.blur = function () { return dispatchFakeEvent(element, 'blur'); };
    }

    /**
     * Focuses an input or textarea, sets its value and dispatches
     * the `input` or `textarea` event, simulating the user typing.
     * @param value Value to be set on the input.
     * @param element Element onto which to set the value.
     *
     * typeInElement('al', input);
     */
    function typeInElement(value, element) {
        if (!(element instanceof HTMLInputElement) && !(element instanceof HTMLTextAreaElement)) {
            return;
        }
        element.focus();
        element.value = value;
        dispatchFakeEvent(element, 'input', true);
    }

    /**
     * Focuses a select element, selects the correct options and dispatches
     * the `change` event, simulating the user selecting an option
     * @param options Options to be selected.
     * @param element Element onto which to select the options.
     * @param config Object with extra config to dispatch change event when option selected
     *
     * selectOption('al' | ['al', 'ab'], select, config);
     */
    function selectOption(options, element, config) {
        if (!(element instanceof HTMLSelectElement)) {
            return;
        }
        element.focus();
        if (isString(options)) {
            var option = element.querySelector("option[value=\"" + options + "\"]");
            if (!option) {
                return;
            }
            setOptionSelected(option, element, config);
        }
        else if (options instanceof HTMLOptionElement) {
            setOptionSelected(options, element, config);
        }
        else {
            if (!element.multiple) {
                return;
            }
            if (isHTMLOptionElementArray(options)) {
                options.forEach(function (option) { return setOptionSelected(option, element, config); });
            }
            else {
                element.querySelectorAll('option').forEach(function (opt) {
                    if (options.includes(opt.value)) {
                        setOptionSelected(opt, element, config);
                    }
                });
            }
        }
    }
    /**
     * Set the option in the HTMLSelectElement to selected
     * @param option HTMLOptionElement to select
     * @param select HTMLSelectElement to add the options to
     * @param config Object with extra config to dispatch change event when option selected
     *
     * setOptionSelected(option, element, config);
     */
    function setOptionSelected(option, select, config) {
        option.selected = true;
        if (config.emitEvents) {
            dispatchFakeEvent(select, 'change', true);
        }
    }

    /**
     * @internal
     */
    var BaseSpectator = /** @class */ (function () {
        function BaseSpectator() {
        }
        BaseSpectator.prototype.inject = function (token) {
            return testing.TestBed.inject ? testing.TestBed.inject(token) : testing.TestBed.get(token);
        };
        return BaseSpectator;
    }());

    var KEY_UP = 'keyup';
    /**
     * @internal
     */
    var DomSpectator = /** @class */ (function (_super) {
        __extends(DomSpectator, _super);
        function DomSpectator(fixture, debugElement, instance, element) {
            var _this = _super.call(this) || this;
            _this.fixture = fixture;
            _this.debugElement = debugElement;
            _this.instance = instance;
            _this.element = element;
            return _this;
        }
        DomSpectator.prototype.inject = function (token) {
            return _super.prototype.inject.call(this, token);
        };
        DomSpectator.prototype.detectChanges = function () {
            this.fixture.detectChanges();
        };
        DomSpectator.prototype.query = function (directiveOrSelector, options) {
            if ((options || {}).root) {
                if (isString(directiveOrSelector)) {
                    return document.querySelector(directiveOrSelector);
                }
                if (directiveOrSelector instanceof DOMSelector) {
                    return directiveOrSelector.execute(document)[0] || null;
                }
            }
            return getChildren(this.debugElement)(directiveOrSelector, options)[0] || null;
        };
        DomSpectator.prototype.queryAll = function (directiveOrSelector, options) {
            if ((options || {}).root) {
                if (isString(directiveOrSelector)) {
                    return Array.from(document.querySelectorAll(directiveOrSelector));
                }
                if (directiveOrSelector instanceof DOMSelector) {
                    return directiveOrSelector.execute(document);
                }
            }
            return getChildren(this.debugElement)(directiveOrSelector, options);
        };
        DomSpectator.prototype.queryLast = function (directiveOrSelector, options) {
            var result = [];
            if ((options || {}).root) {
                if (isString(directiveOrSelector)) {
                    result = Array.from(document.querySelectorAll(directiveOrSelector));
                }
                if (directiveOrSelector instanceof DOMSelector) {
                    result = directiveOrSelector.execute(document);
                }
            }
            else {
                result = getChildren(this.debugElement)(directiveOrSelector, options);
            }
            if (result && result.length) {
                return result[result.length - 1];
            }
            return null;
        };
        DomSpectator.prototype.setInput = function (input, value) {
            setProps(this.instance, input, value, false);
            this.debugElement.injector.get(core.ChangeDetectorRef).detectChanges();
        };
        DomSpectator.prototype.output = function (output) {
            var observable = this.instance[output];
            if (!(observable instanceof rxjs.Observable)) {
                throw new Error(output + " is not an @Output");
            }
            return observable;
        };
        DomSpectator.prototype.tick = function (millis) {
            testing.tick(millis);
            this.detectChanges();
        };
        DomSpectator.prototype.click = function (selector) {
            if (selector === void 0) { selector = this.element; }
            var element = this.getNativeElement(selector);
            if (!(element instanceof HTMLElement)) {
                throw new Error("Cannot click: " + selector + " is not a HTMLElement");
            }
            element.click();
            this.detectChanges();
        };
        DomSpectator.prototype.blur = function (selector) {
            if (selector === void 0) { selector = this.element; }
            var element = this.getNativeElement(selector);
            if (!(element instanceof HTMLElement)) {
                throw new Error("Cannot blur: " + selector + " is not a HTMLElement");
            }
            patchElementFocus(element);
            element.blur();
            this.detectChanges();
        };
        DomSpectator.prototype.focus = function (selector) {
            if (selector === void 0) { selector = this.element; }
            var element = this.getNativeElement(selector);
            if (!(element instanceof HTMLElement)) {
                throw new Error("Cannot focus: " + selector + " is not a HTMLElement");
            }
            patchElementFocus(element);
            element.focus();
            this.detectChanges();
        };
        DomSpectator.prototype.dispatchMouseEvent = function (selector, type, x, y, event) {
            if (selector === void 0) { selector = this.element; }
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            if (event === void 0) { event = createMouseEvent(type, x, y); }
            var element = this.getNativeElement(selector);
            if (!(element instanceof Node)) {
                throw new Error("Cannot dispatch mouse event: " + selector + " is not a node");
            }
            var dispatchedEvent = dispatchMouseEvent(element, type, x, y, event);
            this.detectChanges();
            return dispatchedEvent;
        };
        DomSpectator.prototype.dispatchKeyboardEvent = function (selector, type, keyOrKeyCode, target) {
            if (selector === void 0) { selector = this.element; }
            var element = this.getNativeElement(selector);
            if (!(element instanceof Node)) {
                throw new Error("Cannot dispatch keyboard event: " + selector + " is not a node");
            }
            var event = dispatchKeyboardEvent(element, type, keyOrKeyCode, target);
            this.detectChanges();
            return event;
        };
        DomSpectator.prototype.dispatchFakeEvent = function (selector, type, canBubble) {
            if (selector === void 0) { selector = this.element; }
            var event = dispatchFakeEvent(this.getNativeElement(selector), type, canBubble);
            this.detectChanges();
            return event;
        };
        DomSpectator.prototype.triggerEventHandler = function (directiveOrSelector, eventName, eventObj) {
            var debugElement = this.getDebugElement(directiveOrSelector);
            if (!debugElement) {
                // tslint:disable:no-console
                console.error(directiveOrSelector + " does not exists");
                return;
            }
            debugElement.triggerEventHandler(eventName, eventObj);
            this.detectChanges();
        };
        Object.defineProperty(DomSpectator.prototype, "keyboard", {
            get: function () {
                var _this = this;
                return {
                    pressKey: function (key, selector, event) {
                        if (selector === void 0) { selector = _this.element; }
                        if (event === void 0) { event = KEY_UP; }
                        _this.dispatchKeyboardEvent(selector, event, key);
                    },
                    pressEscape: function (selector, event) {
                        if (selector === void 0) { selector = _this.element; }
                        if (event === void 0) { event = KEY_UP; }
                        _this.dispatchKeyboardEvent(selector, event, { key: 'Escape', keyCode: 27 });
                    },
                    pressEnter: function (selector, event) {
                        if (selector === void 0) { selector = _this.element; }
                        if (event === void 0) { event = KEY_UP; }
                        _this.dispatchKeyboardEvent(selector, event, { key: 'Enter', keyCode: 13 });
                    },
                    pressTab: function (selector, event) {
                        if (selector === void 0) { selector = _this.element; }
                        if (event === void 0) { event = KEY_UP; }
                        _this.dispatchKeyboardEvent(selector, event, { key: 'Tab', keyCode: 9 });
                    },
                    pressBackspace: function (selector, event) {
                        if (selector === void 0) { selector = _this.element; }
                        if (event === void 0) { event = KEY_UP; }
                        _this.dispatchKeyboardEvent(selector, event, { key: 'Backspace', keyCode: 8 });
                    }
                };
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DomSpectator.prototype, "mouse", {
            get: function () {
                var _this = this;
                return {
                    contextmenu: function (selector) {
                        if (selector === void 0) { selector = _this.element; }
                        _this.dispatchMouseEvent(selector, 'contextmenu');
                    },
                    dblclick: function (selector) {
                        if (selector === void 0) { selector = _this.element; }
                        _this.dispatchMouseEvent(selector, 'dblclick');
                    }
                };
            },
            enumerable: false,
            configurable: true
        });
        DomSpectator.prototype.dispatchTouchEvent = function (selector, type, x, y) {
            if (selector === void 0) { selector = this.element; }
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            dispatchTouchEvent(this.getNativeElement(selector), type, x, y);
            this.detectChanges();
        };
        DomSpectator.prototype.typeInElement = function (value, selector) {
            if (selector === void 0) { selector = this.element; }
            typeInElement(value, this.getNativeElement(selector));
            this.detectChanges();
        };
        DomSpectator.prototype.selectOption = function (selector, options, config) {
            if (selector === void 0) { selector = this.element; }
            if (config === void 0) { config = { emitEvents: true }; }
            if (!selector) {
                throw new Error("Cannot find select: " + selector);
            }
            selectOption(options, this.getNativeElement(selector), config);
            this.detectChanges();
        };
        DomSpectator.prototype.getNativeElement = function (selector) {
            var element;
            // Support global objects window and document
            if (selector === window || selector === document) {
                return selector;
            }
            if (isString(selector)) {
                var exists = this.debugElement.query(platformBrowser.By.css(selector));
                if (exists) {
                    element = exists.nativeElement;
                }
                else {
                    // tslint:disable:no-console
                    console.error(selector + " does not exists");
                }
            }
            else if (selector instanceof DOMSelector) {
                element = selector.execute(document)[0] || null;
            }
            else {
                if (selector instanceof core.DebugElement || selector instanceof core.ElementRef) {
                    element = selector.nativeElement;
                }
                else {
                    element = selector;
                }
            }
            return element;
        };
        DomSpectator.prototype.getDebugElement = function (directiveOrSelector) {
            var debugElement;
            if (isString(directiveOrSelector)) {
                debugElement = this.debugElement.query(platformBrowser.By.css(directiveOrSelector));
            }
            else if (directiveOrSelector instanceof core.DebugElement) {
                debugElement = directiveOrSelector;
            }
            else {
                debugElement = this.debugElement.query(platformBrowser.By.directive(directiveOrSelector));
            }
            return debugElement;
        };
        return DomSpectator;
    }(BaseSpectator));

    /**
     * @publicApi
     */
    var Spectator = /** @class */ (function (_super) {
        __extends(Spectator, _super);
        function Spectator(fixture, debugElement, instance, element) {
            var _this = _super.call(this, fixture, debugElement, instance, element) || this;
            _this.fixture = fixture;
            _this.debugElement = debugElement;
            _this.instance = instance;
            _this.element = element;
            return _this;
        }
        Object.defineProperty(Spectator.prototype, "component", {
            get: function () {
                return this.instance;
            },
            enumerable: false,
            configurable: true
        });
        Spectator.prototype.inject = function (token, fromComponentInjector) {
            if (fromComponentInjector === void 0) { fromComponentInjector = false; }
            if (fromComponentInjector) {
                return this.debugElement.injector.get(token);
            }
            return _super.prototype.inject.call(this, token);
        };
        Spectator.prototype.detectComponentChanges = function () {
            if (this.debugElement) {
                this.debugElement.injector.get(core.ChangeDetectorRef).detectChanges();
            }
            else {
                this.detectChanges();
            }
        };
        return Spectator;
    }(DomSpectator));

    /**
     * @license
     * Copyright Netanel Basal. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://github.com/NetanelBasal/spectator/blob/master/LICENSE
     */
    function hex2rgb(hex) {
        var h = hex.replace('#', '');
        var matches = h.match(new RegExp('(.{' + h.length / 3 + '})', 'g'));
        var _a = __read(matches.map(function (match) { return parseInt(match.length === 1 ? match + match : match, 16); }), 3), r = _a[0], g = _a[1], b = _a[2];
        return "rgb(" + r + "," + g + "," + b + ")";
    }
    function isHex(value) {
        return /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(value);
    }
    function trim(value) {
        return (value || '').replace(/\s/g, '');
    }

    function isRunningInJsDom() {
        return navigator.userAgent.includes('Node.js') || navigator.userAgent.includes('jsdom');
    }

    var hasProperty = function (actual, expected) {
        return expected === undefined ? actual !== undefined : actual === expected;
    };
    var ɵ0$1 = hasProperty;
    var containsProperty = function (actual, expected) {
        return expected === undefined ? true : actual.includes(expected);
    };
    var ɵ1 = containsProperty;
    var checkProperty = function (el, prop, predicate) {
        var e_1, _a;
        var pass = false;
        var failing = '';
        try {
            for (var _b = __values(Object.keys(prop)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var key = _c.value;
                var actual = $__default['default'](el).prop(key);
                var addendum = prop[key] !== undefined ? " with value '" + prop[key] + "'" : '';
                pass = predicate(actual, prop[key]);
                failing = !pass ? "'" + prop + "'" + addendum + ", but had '" + actual + "'" : '';
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        var message = function () { return "Expected element" + (pass ? ' not' : '') + " to have property " + failing; };
        return { pass: pass, message: message };
    };
    var ɵ2 = checkProperty;
    var hasCss = function (el, css) {
        var prop;
        var value;
        var $el = $__default['default'](el);
        for (prop in css) {
            if (css.hasOwnProperty(prop)) {
                value = css[prop];
                if (isHex(value)) {
                    value = hex2rgb(css[prop]);
                }
                if (value === 'auto' && $el.get(0).style[prop] === 'auto') {
                    continue;
                }
                if (trim($el.css(prop)) !== trim(value) && trim(el.style[prop]) !== trim(value)) {
                    return false;
                }
            }
        }
        return true;
    };
    var ɵ3 = hasCss;
    var hasSameText = function (el, expected, exact) {
        if (exact === void 0) { exact = false; }
        if (expected && Array.isArray(expected)) {
            var actual_1;
            var pass_1 = false;
            var failing_1;
            $__default['default'](el).each(function (i, e) {
                actual_1 = exact ? $__default['default'](e).text() : $__default['default'].trim($__default['default'](e).text());
                pass_1 = exact ? actual_1 === expected[i] : actual_1.includes(expected[i]);
                if (!pass_1) {
                    failing_1 = expected[i];
                    return false;
                }
            });
            var message_1 = function () { return "Expected element" + (pass_1 ? ' not' : '') + " to have " + (exact ? 'exact' : '') + " text '" + failing_1 + "', but had '" + actual_1 + "'"; };
            return { pass: pass_1, message: message_1 };
        }
        var actual = exact ? $__default['default'](el).text() : $__default['default'].trim($__default['default'](el).text());
        if (expected && typeof expected !== 'string') {
            var pass_2 = expected(actual);
            var message_2 = function () { return "Expected element" + (pass_2 ? ' not' : '') + " to have " + (exact ? 'exact' : '') + " text matching '" + expected + "'," + (" but had '" + actual + "'"); };
            return { pass: pass_2, message: message_2 };
        }
        var pass = exact && !Array.isArray(expected) ? actual === expected : actual.indexOf(expected) !== -1;
        var message = function () { return "Expected element" + (pass ? ' not' : '') + " to have " + (exact ? 'exact' : '') + " text '" + expected + "', but had '" + actual + "'"; };
        return { pass: pass, message: message };
    };
    var ɵ4 = hasSameText;
    var comparator = function (func) { return function () { return ({
        compare: func
    }); }; };
    var ɵ5 = comparator;
    var ɵ6 = function (el) {
        var actual = $__default['default'](el).length;
        var pass = actual > 0;
        var message = function () { return "Expected " + el + " element" + (pass ? ' not' : '') + " to exist"; };
        return { pass: pass, message: message };
    };
    /**
     *
     * expect('.zippy__content').not.toExist();
     */
    var toExist = comparator(ɵ6);
    var ɵ7 = function (el, expected) {
        var actual = $__default['default'](el).length;
        var pass = actual === expected;
        var message = function () { return "Expected element" + (pass ? ' not' : '') + " to have length " + expected + ", but had " + actual; };
        return { pass: pass, message: message };
    };
    /**
     *
     * expect('.zippy__content').toHaveLength(3);
     */
    var toHaveLength = comparator(ɵ7);
    var ɵ8 = function (el, expected) {
        var actual = $__default['default'](el).attr('id');
        var pass = actual === expected;
        var message = function () { return "Expected element" + (pass ? ' not' : '') + " to have ID '" + expected + "', but had '" + actual + "'"; };
        return { pass: pass, message: message };
    };
    /**
     *
     * expect('.zippy__content').toHaveId('ID');
     */
    var toHaveId = comparator(ɵ8);
    var ɵ9 = function (el, expected) {
        if (expected && Array.isArray(expected)) {
            var actual_2 = $__default['default'](el).attr('class');
            var expectedClasses_1 = expected.join(' ');
            var pass_3 = $__default['default'](el).hasClass(expectedClasses_1);
            var message_3 = function () { return "Expected element" + (pass_3 ? ' not' : '') + " to have value '" + expectedClasses_1 + "', but had '" + actual_2 + "'"; };
            return { pass: pass_3, message: message_3 };
        }
        var actual = $__default['default'](el).attr('class');
        var pass = $__default['default'](el).hasClass(expected);
        var message = function () { return "Expected element" + (pass ? ' not' : '') + " to have class '" + expected + "', but had '" + actual + "'"; };
        return { pass: pass, message: message };
    };
    /**
     *
     * expect('.zippy__content').toHaveClass('class');
     * expect('.zippy__content').toHaveClass('class a, class b');
     * expect('.zippy__content').toHaveClass(['class a, class b']);
     */
    var toHaveClass = comparator(ɵ9);
    var ɵ10 = function (el, attr, val) {
        var e_2, _a;
        if (isObject(attr)) {
            var pass_4 = false;
            var failing_2;
            try {
                for (var _b = __values(Object.keys(attr)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var key = _c.value;
                    var actual_3 = $__default['default'](el).attr(key);
                    var addendum_1 = attr[key] !== undefined ? " with value '" + attr[key] + "'" : '';
                    pass_4 = hasProperty(actual_3, attr[key]);
                    failing_2 = !pass_4 ? "'" + attr + "'" + addendum_1 + ", but had '" + actual_3 + "'" : '';
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
            var message_4 = function () { return "Expected element" + (pass_4 ? ' not' : '') + " to have attribute " + failing_2; };
            return { pass: pass_4, message: message_4 };
        }
        var actual = $__default['default'](el).attr(attr);
        var addendum = val !== undefined ? " with value '" + val + "'" : '';
        var pass = hasProperty(actual, val);
        var message = function () { return "Expected element" + (pass ? ' not' : '') + " to have attribute '" + attr + "'" + addendum + ", but had '" + actual + "'"; };
        return { pass: pass, message: message };
    };
    /**
     * expect(host.query('.zippy')).toHaveAttribute('id', 'zippy');
     */
    var toHaveAttribute = comparator(ɵ10);
    var ɵ11 = function (el, prop, val) {
        if (isObject(prop)) {
            return checkProperty(el, prop, hasProperty);
        }
        var actual = $__default['default'](el).prop(prop);
        var addendum = val !== undefined ? " with value '" + val + "'" : '';
        var pass = hasProperty(actual, val);
        var message = function () { return "Expected element" + (pass ? ' not' : '') + " to have property '" + prop + "'" + addendum + ", but had '" + actual + "'"; };
        return { pass: pass, message: message };
    };
    /**
     *  expect(host.query('.checkbox')).toHaveProperty('checked', true);
     *  expect(host.query('.checkbox')).toHaveProperty({checked: true});
     */
    var toHaveProperty = comparator(ɵ11);
    var ɵ12 = function (el, prop, val) {
        if (isObject(prop)) {
            return checkProperty(el, prop, containsProperty);
        }
        var actual = $__default['default'](el).prop(prop);
        var addendum = val !== undefined ? " with value '" + val + "'" : '';
        var pass = containsProperty(actual, val);
        var message = function () { return "Expected element" + (pass ? ' not' : '') + " to have property '" + prop + "'" + addendum + ", but had '" + actual + "'"; };
        return { pass: pass, message: message };
    };
    var toContainProperty = comparator(ɵ12);
    var ɵ13 = function (el, expected, exact) {
        if (exact === void 0) { exact = false; }
        return hasSameText(el, expected, exact);
    };
    /**
     *
     * expect('.zippy__content').toHaveText('Content');
     * expect('.zippy__content').toHaveText(['Content A', 'Content B']);
     *
     * expect('.zippy__content').toHaveText((text) => text.includes('..');
     */
    var toHaveText = comparator(ɵ13);
    var ɵ14 = function (el, expected) { return hasSameText(el, expected, true); };
    var toHaveExactText = comparator(ɵ14);
    var toContainText = toHaveText;
    var ɵ15 = function (el, expected) {
        if (expected && Array.isArray(expected)) {
            var actual_4;
            var pass_5 = false;
            var failing_3;
            $__default['default'](el).each(function (i, e) {
                actual_4 = $__default['default'](e).val();
                pass_5 = actual_4 === expected[i];
                if (!pass_5) {
                    failing_3 = expected[i];
                    return false;
                }
            });
            var message_5 = function () { return "Expected element" + (pass_5 ? ' not' : '') + " to have value '" + failing_3 + "', but had '" + actual_4 + "'"; };
            return { pass: pass_5, message: message_5 };
        }
        var actual = $__default['default'](el).val();
        var pass = actual === expected;
        var message = function () { return "Expected element" + (pass ? ' not' : '') + " to have value '" + expected + "', but had '" + actual + "'"; };
        return { pass: pass, message: message };
    };
    /**
     *
     * expect('.zippy__content').toHaveValue('value');
     * expect('.zippy__content').toHaveValue(['value a', 'value b']);
     */
    var toHaveValue = comparator(ɵ15);
    var toContainValue = toHaveValue;
    var ɵ16 = function (el, expected) {
        var pass = hasCss(el, expected);
        var message = function () { return "Expected element" + (pass ? ' not' : '') + " to have CSS " + JSON.stringify(expected); };
        return { pass: pass, message: message };
    };
    /**
     *
     *  expect(host.element).toHaveStyle({
     *    backgroundColor: 'rgba(0, 0, 0, 0.1)'
     *  });
     */
    var toHaveStyle = comparator(ɵ16);
    var ɵ17 = function (el, _a) {
        var data = _a.data, val = _a.val;
        var actual = $__default['default'](el).data(data);
        var addendum = val !== undefined ? " with value '" + val + "'" : '';
        var pass = hasProperty(actual, val);
        var message = function () { return "Expected element" + (pass ? ' not' : '') + " to have data '" + data + "'" + addendum + ", but had '" + actual + "'"; };
        return { pass: pass, message: message };
    };
    /**
     *
     * expect('.zippy__content').toHaveData({data: 'role', val: 'admin'});
     */
    var toHaveData = comparator(ɵ17);
    var ɵ18 = function (el) {
        var pass = $__default['default'](el).is(':checked');
        var message = function () { return "Expected element" + (pass ? ' not' : '') + " to be checked"; };
        return { pass: pass, message: message };
    };
    /**
     *
     * expect('.checkbox').toBeChecked();
     */
    var toBeChecked = comparator(ɵ18);
    var ɵ19 = function (el) {
        var pass = $__default['default'](el).is(':disabled');
        var message = function () { return "Expected element" + (pass ? ' not' : '') + " to be disabled"; };
        return { pass: pass, message: message };
    };
    /**
     *
     * expect('.checkbox').toBeDisabled();
     */
    var toBeDisabled = comparator(ɵ19);
    var ɵ20 = function (el) {
        var pass = $__default['default'](el).is(':empty');
        var message = function () { return "Expected element" + (pass ? ' not' : '') + " to be empty"; };
        return { pass: pass, message: message };
    };
    /**
     * An empty element is an element without child elements or text.
     *
     * expect('div').toBeEmpty();
     */
    var toBeEmpty = comparator(ɵ20);
    /**
     * Hidden elements are elements that have:
     * 1. Display property set to "none"
     * 2. Width and height set to 0 (check not applied in jest)
     * 3. A hidden parent element (this also hides child elements)
     * 4. Type equal to "hidden" (only for form elements)
     * 5. A "hidden" attribute
     */
    function isHidden(elOrSelector) {
        var el = $__default['default'](elOrSelector)[0];
        if (!el) {
            return true;
        }
        var hiddenWhen = [
            function (el) { return !(el.offsetWidth || el.offsetHeight || el.getClientRects().length); },
            function (el) { return el.style.display === 'none'; },
            function (el) { return el.style.visibility === 'hidden'; },
            function (el) { return el.type === 'hidden'; },
            function (el) { return el.hasAttribute('hidden'); }
        ];
        if (isRunningInJsDom()) {
            // When running in JSDOM (Jest), offset-properties and client rects are always reported as 0
            // - hence, let's take a more "naive" approach here. (https://github.com/jsdom/jsdom/issues/135)
            hiddenWhen.shift();
        }
        while (el) {
            if (el === document) {
                break;
            }
            if (hiddenWhen.some(function (rule) { return rule(el); })) {
                return true;
            }
            el = el.parentNode;
        }
        return false;
    }
    var ɵ21 = function (el) {
        var pass = isHidden(el);
        var message = function () { return "Expected element" + (pass ? ' not' : '') + " to be hidden"; };
        return { pass: pass, message: message };
    };
    /**
     * Hidden elements are elements that have:
     * 1. Display property set to "none"
     * 2. Width and height set to 0
     * 3. A hidden parent element (this also hides child elements)
     * 4. Type equal to "hidden" (only for form elements)
     * 5. A "hidden" attribute
     *
     * expect('div').toBeHidden();
     *
     */
    var toBeHidden = comparator(ɵ21);
    var ɵ22 = function (el) {
        var pass = $__default['default'](el).is(':selected');
        var message = function () { return "Expected element" + (pass ? ' not' : '') + " to be selected"; };
        return { pass: pass, message: message };
    };
    /**
     * The :selected selector selects option elements that are pre-selected.
     *
     * expect('div').toBeSelected();
     *
     */
    var toBeSelected = comparator(ɵ22);
    var ɵ23 = function (el) {
        var pass = !isHidden(el);
        var message = function () { return "Expected element" + (pass ? ' not' : '') + " to be visible"; };
        return { pass: pass, message: message };
    };
    /**
     * Hidden elements are elements that have:
     * 1. Display property set to "none"
     * 2. Width and height set to 0
     * 3. A hidden parent element (this also hides child elements)
     * 4. Type equal to "hidden" (only for form elements)
     * 5. A "hidden" attribute
     *
     * expect('div').toBeVisible();
     *
     */
    var toBeVisible = comparator(ɵ23);
    var ɵ24 = function (el) {
        var element = $__default['default'](el).get(0);
        var pass = element === element.ownerDocument.activeElement;
        var message = function () { return "Expected element" + (pass ? ' not' : '') + " to be focused"; };
        return { pass: pass, message: message };
    };
    /**
     * The :focus selector selects the element that currently has focus.
     *
     * expect('input').toBeFocused();
     */
    var toBeFocused = comparator(ɵ24);
    var ɵ25 = function (el, expected) {
        var actual = $__default['default'](el).filter(expected).length;
        var pass = actual > 0;
        var message = function () { return "Expected element" + (pass ? ' not' : '') + " to be matched by '" + expected + "'"; };
        return { pass: pass, message: message };
    };
    /**
     * Check to see if the set of matched elements matches the given selector
     * returns true if the dom contains the element
     *
     * expect('div').toBeMatchedBy('.js-something')
     */
    var toBeMatchedBy = comparator(ɵ25);
    var ɵ26 = function (el, selector) {
        var actual = $__default['default'](el).find(selector).length;
        var pass = actual > 0;
        var message = function () { return "Expected element" + (pass ? ' not' : '') + " to contain child '" + selector + "'"; };
        return { pass: pass, message: message };
    };
    /**
     *
     * expect('div').toHaveDescendant('.child')
     */
    var toHaveDescendant = comparator(ɵ26);
    var ɵ27 = function (el, _a) {
        var selector = _a.selector, text = _a.text;
        var actual = $__default['default'].trim($__default['default'](el)
            .find(selector)
            .text());
        if (text && $__default['default'].isFunction(text.test)) {
            var pass_6 = text.test(actual);
            var message_6 = function () { return "Expected element" + (pass_6 ? ' not' : '') + " to have descendant '" + selector + "' with text matching '" + text + "'," + (" but had '" + actual + "'"); };
            return { pass: pass_6, message: message_6 };
        }
        var pass = actual.indexOf(text) !== -1;
        var message = function () { return "Expected element" + (pass ? ' not' : '') + " to have descendant '" + selector + "' with text '" + text + "', but had '" + actual + "'"; };
        return { pass: pass, message: message };
    };
    /**
     *
     * expect('div').toHaveDescendantWithText({selector: '.child', text: 'text'})
     */
    var toHaveDescendantWithText = comparator(ɵ27);
    var ɵ28 = function (el, expected) {
        if (expected instanceof HTMLOptionElement) {
            var actual_5 = $__default['default'](el).find(':selected');
            var pass_7 = actual_5.is($__default['default'](expected));
            var message_7 = function () { return "Expected element" + (pass_7 ? ' not' : '') + " to have options '[" + expected.outerHTML + "]' but had '[" + actual_5[0].outerHTML + "]'"; };
            return { pass: pass_7, message: message_7 };
        }
        if (isHTMLOptionElementArray(expected)) {
            var actual_6 = $__default['default'](el).find(':selected');
            var pass_8 = actual_6.length === expected.length && actual_6.toArray().every(function (_, index) { return $__default['default'](actual_6[index]).is(expected[index]); });
            var expectedOptionsString_1 = $__default['default'](expected)
                .get()
                .map(function (option) { return option.outerHTML; })
                .join(',');
            var actualOptionsString_1 = actual_6
                .get()
                .map(function (option) { return option.outerHTML; })
                .join(',');
            var message_8 = function () { return "Expected element" + (pass_8 ? ' not' : '') + " to have options '[" + expectedOptionsString_1 + "]' but had '[" + actualOptionsString_1 + "]'"; };
            return { pass: pass_8, message: message_8 };
        }
        var actual = $__default['default'](el).val();
        var pass = JSON.stringify(__spread(actual)) === JSON.stringify(__spread(expected));
        var expectedOptionsString = Array.isArray(expected)
            ? expected.reduce(function (acc, val, i) { return acc + ("" + (i === expected.length ? '' : ',') + val); })
            : expected;
        var message = function () { return "Expected element" + (pass ? ' not' : '') + " to have options '[" + expectedOptionsString + "]' but had '[" + actual + "]'"; };
        return { pass: pass, message: message };
    };
    var toHaveSelectedOptions = comparator(ɵ28);

    var customMatchers = /*#__PURE__*/Object.freeze({
        __proto__: null,
        toExist: toExist,
        toHaveLength: toHaveLength,
        toHaveId: toHaveId,
        toHaveClass: toHaveClass,
        toHaveAttribute: toHaveAttribute,
        toHaveProperty: toHaveProperty,
        toContainProperty: toContainProperty,
        toHaveText: toHaveText,
        toHaveExactText: toHaveExactText,
        toContainText: toContainText,
        toHaveValue: toHaveValue,
        toContainValue: toContainValue,
        toHaveStyle: toHaveStyle,
        toHaveData: toHaveData,
        toBeChecked: toBeChecked,
        toBeDisabled: toBeDisabled,
        toBeEmpty: toBeEmpty,
        toBeHidden: toBeHidden,
        toBeSelected: toBeSelected,
        toBeVisible: toBeVisible,
        toBeFocused: toBeFocused,
        toBeMatchedBy: toBeMatchedBy,
        toHaveDescendant: toHaveDescendant,
        toHaveDescendantWithText: toHaveDescendantWithText,
        toHaveSelectedOptions: toHaveSelectedOptions,
        ɵ0: ɵ0$1,
        ɵ1: ɵ1,
        ɵ2: ɵ2,
        ɵ3: ɵ3,
        ɵ4: ɵ4,
        ɵ5: ɵ5,
        ɵ6: ɵ6,
        ɵ7: ɵ7,
        ɵ8: ɵ8,
        ɵ9: ɵ9,
        ɵ10: ɵ10,
        ɵ11: ɵ11,
        ɵ12: ɵ12,
        ɵ13: ɵ13,
        ɵ14: ɵ14,
        ɵ15: ɵ15,
        ɵ16: ɵ16,
        ɵ17: ɵ17,
        ɵ18: ɵ18,
        ɵ19: ɵ19,
        ɵ20: ɵ20,
        ɵ21: ɵ21,
        ɵ22: ɵ22,
        ɵ23: ɵ23,
        ɵ24: ɵ24,
        ɵ25: ɵ25,
        ɵ26: ɵ26,
        ɵ27: ɵ27,
        ɵ28: ɵ28
    });

    function addMatchers(matchers) {
        var e_1, _a;
        if (!matchers)
            return;
        if (typeof jasmine !== 'undefined') {
            jasmine.addMatchers(matchers);
        }
        if (typeof jest !== 'undefined') {
            var jestExpectExtend = {};
            try {
                for (var _b = __values(Object.keys(matchers)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var key = _c.value;
                    if (key.startsWith('to'))
                        jestExpectExtend[key] = matchers[key]().compare;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            expect.extend(jestExpectExtend);
        }
    }

    var globals = {
        providers: [],
        declarations: [],
        imports: []
    };
    function defineGlobalsInjections(config) {
        globals = Object.assign(Object.assign({}, globals), config);
    }
    function getGlobalsInjections() {
        return globals;
    }

    /**
     * @internal
     */
    function initialModule(options) {
        var globals = Object.assign({ imports: [], declarations: [], providers: [] }, getGlobalsInjections());
        return {
            declarations: __spread(globals.declarations, options.declarations, options.entryComponents),
            imports: __spread((options.disableAnimations ? [animations.NoopAnimationsModule] : []), globals.imports, options.imports),
            providers: __spread(globals.providers, options.providers, options.mocks.map(function (type) { return options.mockProvider(type); })),
            entryComponents: __spread(options.entryComponents)
        };
    }

    /**
     * @internal
     */
    function initialSpectatorModule(options) {
        var moduleMetadata = initialModule(options);
        if (options.declareComponent) {
            moduleMetadata.declarations.push(options.component);
        }
        moduleMetadata.schemas = [options.shallow ? core.NO_ERRORS_SCHEMA : options.schemas || []];
        return moduleMetadata;
    }

    /**
     * @internal
     */
    function merge(defaults, overrides) {
        // tslint:disable-next-line:no-object-literal-type-assertion
        return Object.assign(Object.assign({}, defaults), overrides);
    }

    /**
     * @internal
     */
    function installProtoMethods(mock, proto, createSpyFn) {
        var e_1, _a;
        if (proto === null || proto === Object.prototype) {
            return;
        }
        var _loop_1 = function (key) {
            var descriptor = Object.getOwnPropertyDescriptor(proto, key);
            if (!descriptor) {
                return "continue";
            }
            if (typeof descriptor.value === 'function' && key !== 'constructor' && typeof mock[key] === 'undefined') {
                mock[key] = createSpyFn(key);
            }
            else if (descriptor.get && !mock.hasOwnProperty(key)) {
                Object.defineProperty(mock, key, {
                    set: function (value) { return (mock["_" + key] = value); },
                    get: function () { return mock["_" + key]; },
                    configurable: true
                });
            }
        };
        try {
            for (var _b = __values(Object.getOwnPropertyNames(proto)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var key = _c.value;
                _loop_1(key);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        installProtoMethods(mock, Object.getPrototypeOf(proto), createSpyFn);
        mock.castToWritable = function () { return mock; };
    }
    /**
     * @publicApi
     */
    function createSpyObject(type, template) {
        var mock = Object.assign({}, template) || {};
        installProtoMethods(mock, type.prototype, function (name) {
            var newSpy = jasmine.createSpy(name);
            newSpy.andCallFake = function (fn) { return newSpy.and.callFake(fn); };
            newSpy.andReturn = function (val) { return newSpy.and.returnValue(val); };
            newSpy.reset = function () { return newSpy.calls.reset(); };
            // revisit return null here (previously needed for rtts_assert).
            newSpy.and.returnValue(null);
            return newSpy;
        });
        return mock;
    }
    /**
     * @publicApi
     */
    function mockProvider(type, properties) {
        return {
            provide: type,
            useFactory: function () { return createSpyObject(type, properties); }
        };
    }

    var defaultOptions = {
        disableAnimations: true,
        entryComponents: [],
        mocks: [],
        mockProvider: mockProvider,
        providers: [],
        declarations: [],
        imports: [],
        schemas: [],
        overrideModules: []
    };
    /**
     * @internal
     */
    function getDefaultBaseOptions(options) {
        return merge(defaultOptions, options);
    }

    var defaultSpectatorOptions = Object.assign(Object.assign({}, getDefaultBaseOptions()), { shallow: false, declareComponent: true, detectChanges: true, componentProviders: [], componentViewProviders: [], componentMocks: [], componentViewProvidersMocks: [] });
    /**
     * @internal
     */
    function getSpectatorDefaultOptions(overrides) {
        return merge(defaultSpectatorOptions, overrides);
    }

    /**
     * @internal
     */
    function overrideComponentIfProviderOverridesSpecified(options) {
        var hasProviderOverrides = options.componentProviders.length || options.componentMocks.length;
        var hasViewProviders = options.componentViewProviders.length || options.componentViewProvidersMocks.length;
        if (hasProviderOverrides || hasViewProviders) {
            var providerConfiguration = {};
            if (hasProviderOverrides) {
                providerConfiguration = {
                    providers: __spread(options.componentProviders, options.componentMocks.map(function (p) { return options.mockProvider(p); }))
                };
            }
            if (hasViewProviders) {
                providerConfiguration = Object.assign(Object.assign({}, providerConfiguration), { viewProviders: __spread(options.componentViewProviders, options.componentViewProvidersMocks.map(function (p) { return options.mockProvider(p); })) });
            }
            testing.TestBed.overrideComponent(options.component, {
                set: providerConfiguration
            });
        }
    }
    /**
     * @internal
     */
    function overrideModules(options) {
        if (options.overrideModules.length) {
            options.overrideModules.forEach(function (overrideModule) {
                var _a = __read(overrideModule, 2), ngModule = _a[0], override = _a[1];
                testing.TestBed.overrideModule(ngModule, override);
            });
        }
    }
    /**
     * @publicApi
     */
    function createComponentFactory(typeOrOptions) {
        var options = isType(typeOrOptions)
            ? getSpectatorDefaultOptions({ component: typeOrOptions })
            : getSpectatorDefaultOptions(typeOrOptions);
        var moduleMetadata = initialSpectatorModule(options);
        beforeEach(testing.async(function () {
            addMatchers(customMatchers);
            testing.TestBed.configureTestingModule(moduleMetadata).overrideModule(testing$1.BrowserDynamicTestingModule, {
                set: {
                    entryComponents: moduleMetadata.entryComponents
                }
            });
            overrideModules(options);
            overrideComponentIfProviderOverridesSpecified(options);
            testing.TestBed.compileComponents();
        }));
        return function (overrides) {
            var defaults = { props: {}, detectChanges: true, providers: [] };
            var _a = Object.assign(Object.assign({}, defaults), overrides), detectChanges = _a.detectChanges, props = _a.props, providers = _a.providers;
            if (providers && providers.length) {
                providers.forEach(function (provider) {
                    testing.TestBed.overrideProvider(provider.provide, provider);
                });
            }
            var spectator = createSpectator(options, props);
            if (options.detectChanges && detectChanges) {
                spectator.detectChanges();
            }
            return spectator;
        };
    }
    function createSpectator(options, props) {
        var fixture = testing.TestBed.createComponent(options.component);
        var debugElement = fixture.debugElement;
        var component = setProps(fixture.componentInstance, props);
        return new Spectator(fixture, debugElement, component, debugElement.nativeElement);
    }

    /**
     * @publicApi
     */
    var SpectatorHost = /** @class */ (function (_super) {
        __extends(SpectatorHost, _super);
        function SpectatorHost(hostComponent, hostDebugElement, hostElement, hostFixture, debugElement, componentInstance, element) {
            var _this = _super.call(this, hostFixture, debugElement, componentInstance, element) || this;
            _this.hostComponent = hostComponent;
            _this.hostDebugElement = hostDebugElement;
            _this.hostElement = hostElement;
            _this.hostFixture = hostFixture;
            _this.debugElement = debugElement;
            _this.element = element;
            return _this;
        }
        SpectatorHost.prototype.queryHost = function (directiveOrSelector, options) {
            if ((options || {}).root && isString(directiveOrSelector)) {
                return document.querySelector(directiveOrSelector);
            }
            return getChildren(this.hostDebugElement)(directiveOrSelector, options)[0] || null;
        };
        SpectatorHost.prototype.queryHostAll = function (directiveOrSelector, options) {
            if ((options || {}).root && isString(directiveOrSelector)) {
                return Array.from(document.querySelectorAll(directiveOrSelector));
            }
            return getChildren(this.hostDebugElement)(directiveOrSelector, options);
        };
        SpectatorHost.prototype.setHostInput = function (input, value) {
            setProps(this.hostComponent, input, value, false);
            this.detectChanges();
        };
        return SpectatorHost;
    }(Spectator));

    // TODO (dirkluijk): remove after upgrading to Angular 8.2
    // see: https://github.com/angular/angular/commit/10a1e1974b816ebb979dc10586b160ee07ad8356
    function nodeByDirective(type) {
        return function (debugNode) { return debugNode.providerTokens.includes(type); };
    }

    /**
     * @internal
     */
    function initialSpectatorWithHostModule(options) {
        var moduleMetadata = initialSpectatorModule(options);
        moduleMetadata.declarations.push(options.host);
        return moduleMetadata;
    }

    var HostComponent = /** @class */ (function () {
        function HostComponent() {
        }
        return HostComponent;
    }());
    HostComponent.decorators = [
        { type: core.Component, args: [{
                    template: ''
                },] }
    ];
    /*
      This is an unused module to resolve the ng build error:
        'Cannot determine the module for class HostComponent'

      Reference: https://github.com/angular/issues/13590
    */
    var HostModule = /** @class */ (function () {
        function HostModule() {
        }
        return HostModule;
    }());
    HostModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [HostComponent]
                },] }
    ];

    var defaultSpectatorHostOptions = Object.assign(Object.assign({}, getSpectatorDefaultOptions()), { host: HostComponent, template: '' });
    /**
     * @internal
     */
    function getSpectatorHostDefaultOptions(overrides) {
        return merge(defaultSpectatorHostOptions, overrides);
    }

    function createHostFactory(typeOrOptions) {
        var options = isType(typeOrOptions)
            ? getSpectatorHostDefaultOptions({ component: typeOrOptions })
            : getSpectatorHostDefaultOptions(typeOrOptions);
        var moduleMetadata = initialSpectatorWithHostModule(options);
        beforeEach(testing.async(function () {
            addMatchers(customMatchers);
            testing.TestBed.configureTestingModule(moduleMetadata);
            overrideModules(options);
            overrideComponentIfProviderOverridesSpecified(options);
        }));
        return function (template, overrides) {
            var defaults = { props: {}, hostProps: {}, detectChanges: true, providers: [] };
            var _a = Object.assign(Object.assign({}, defaults), overrides), detectChanges = _a.detectChanges, props = _a.props, hostProps = _a.hostProps, providers = _a.providers;
            if (providers && providers.length) {
                providers.forEach(function (provider) {
                    testing.TestBed.overrideProvider(provider.provide, provider);
                });
            }
            testing.TestBed.overrideModule(testing$1.BrowserDynamicTestingModule, {
                set: {
                    entryComponents: moduleMetadata.entryComponents
                }
            }).overrideComponent(options.host, {
                set: { template: template || options.template }
            });
            var spectator = createSpectatorHost(options, props, hostProps);
            if (options.detectChanges && detectChanges) {
                spectator.detectChanges();
            }
            return spectator;
        };
    }
    function createSpectatorHost(options, props, hostProps) {
        var hostFixture = testing.TestBed.createComponent(options.host);
        var debugElement = hostFixture.debugElement.query(platformBrowser.By.directive(options.component)) || hostFixture.debugElement;
        var debugNode = hostFixture.debugElement.queryAllNodes(nodeByDirective(options.component))[0];
        if (!debugNode) {
            throw new Error("Cannot find component/directive " + options.component + " in host template \uD83D\uDE14");
        }
        var hostComponent = setProps(hostFixture.componentInstance, hostProps);
        var component = setProps(debugNode.injector.get(options.component), props);
        return new SpectatorHost(hostComponent, hostFixture.debugElement, hostFixture.nativeElement, hostFixture, debugElement, component, debugElement.nativeElement);
    }

    /**
     * @publicApi
     */
    var SpectatorDirective = /** @class */ (function (_super) {
        __extends(SpectatorDirective, _super);
        function SpectatorDirective(hostComponent, fixture, debugElement, instance, element) {
            var _this = _super.call(this, fixture, debugElement, instance, element) || this;
            _this.hostComponent = hostComponent;
            _this.fixture = fixture;
            _this.debugElement = debugElement;
            _this.instance = instance;
            _this.element = element;
            return _this;
        }
        Object.defineProperty(SpectatorDirective.prototype, "directive", {
            get: function () {
                return this.instance;
            },
            enumerable: false,
            configurable: true
        });
        SpectatorDirective.prototype.inject = function (token, fromDirectiveInjector) {
            if (fromDirectiveInjector === void 0) { fromDirectiveInjector = false; }
            if (fromDirectiveInjector) {
                return this.debugElement.injector.get(token);
            }
            return _super.prototype.inject.call(this, token);
        };
        SpectatorDirective.prototype.setHostInput = function (input, value) {
            setProps(this.hostComponent, input, value, false);
            this.detectChanges();
        };
        return SpectatorDirective;
    }(DomSpectator));

    /**
     * @internal
     */
    function initialSpectatorDirectiveModule(options) {
        var moduleMetadata = initialModule(options);
        if (options.declareDirective) {
            moduleMetadata.declarations.push(options.directive);
        }
        moduleMetadata.declarations.push(options.host);
        moduleMetadata.schemas = [options.shallow ? core.NO_ERRORS_SCHEMA : options.schemas || []];
        return moduleMetadata;
    }

    var defaultSpectatorRoutingOptions = Object.assign(Object.assign({}, getDefaultBaseOptions()), { host: HostComponent, template: '', shallow: false, detectChanges: true, directiveProviders: [], directiveMocks: [], declareDirective: true });
    /**
     * @internal
     */
    function getSpectatorDirectiveDefaultOptions(overrides) {
        return merge(defaultSpectatorRoutingOptions, overrides);
    }

    function createDirectiveFactory(typeOrOptions) {
        var options = isType(typeOrOptions)
            ? getSpectatorDirectiveDefaultOptions({ directive: typeOrOptions })
            : getSpectatorDirectiveDefaultOptions(typeOrOptions);
        var moduleMetadata = initialSpectatorDirectiveModule(options);
        beforeEach(testing.async(function () {
            addMatchers(customMatchers);
            testing.TestBed.configureTestingModule(moduleMetadata);
            overrideModules(options);
        }));
        return function (template, overrides) {
            var defaults = {
                props: {},
                hostProps: {},
                detectChanges: true,
                providers: []
            };
            var _a = Object.assign(Object.assign({}, defaults), overrides), detectChanges = _a.detectChanges, props = _a.props, hostProps = _a.hostProps, providers = _a.providers;
            if (providers && providers.length) {
                providers.forEach(function (provider) {
                    testing.TestBed.overrideProvider(provider.provide, provider);
                });
            }
            testing.TestBed.overrideModule(testing$1.BrowserDynamicTestingModule, {
                set: {
                    entryComponents: moduleMetadata.entryComponents
                }
            }).overrideComponent(options.host, {
                set: { template: template || options.template }
            });
            if (options.directiveProviders.length || options.directiveMocks.length) {
                testing.TestBed.overrideDirective(options.directive, {
                    set: { providers: __spread(options.directiveProviders, options.directiveMocks.map(function (p) { return options.mockProvider(p); })) }
                });
            }
            var spectator = createSpectatorDirective(options, props, hostProps);
            if (options.detectChanges && detectChanges) {
                spectator.detectChanges();
            }
            return spectator;
        };
    }
    function createSpectatorDirective(options, props, hostProps) {
        var hostFixture = testing.TestBed.createComponent(options.host);
        var debugElement = hostFixture.debugElement.query(platformBrowser.By.directive(options.directive)) || hostFixture.debugElement;
        var debugNode = hostFixture.debugElement.queryAllNodes(nodeByDirective(options.directive))[0];
        if (!debugNode) {
            throw new Error("Cannot find directive " + options.directive + " in host template \uD83D\uDE14");
        }
        var hostComponent = setProps(hostFixture.componentInstance, hostProps);
        var directive = setProps(debugNode.injector.get(options.directive), props);
        return new SpectatorDirective(hostComponent, hostFixture, hostFixture.debugElement, directive, debugElement.nativeElement);
    }

    /**
     * @publicApi
     */
    var SpectatorService = /** @class */ (function (_super) {
        __extends(SpectatorService, _super);
        function SpectatorService(service) {
            var _this = _super.call(this) || this;
            _this.service = service;
            return _this;
        }
        return SpectatorService;
    }(BaseSpectator));

    /**
     * @internal
     */
    function initialServiceModule(options) {
        var moduleMetadata = initialModule(options);
        moduleMetadata.providers.push(options.service);
        return moduleMetadata;
    }

    var defaultServiceOptions = Object.assign({}, getDefaultBaseOptions());
    /**
     * @internal
     */
    function getDefaultServiceOptions(overrides) {
        return merge(defaultServiceOptions, overrides);
    }

    /**
     * @publicApi
     */
    function createServiceFactory(typeOrOptions) {
        var service = isType(typeOrOptions) ? typeOrOptions : typeOrOptions.service;
        var options = isType(typeOrOptions) ? getDefaultServiceOptions({ service: service }) : getDefaultServiceOptions(typeOrOptions);
        var moduleMetadata = initialServiceModule(options);
        beforeEach(function () {
            testing.TestBed.configureTestingModule(moduleMetadata);
            overrideModules(options);
        });
        afterEach(function () {
            var testedService = testing.TestBed.inject
                ? testing.TestBed.inject(service)
                : testing.TestBed.get(service);
            if (doesServiceImplementsOnDestroy(testedService)) {
                // tslint:disable-next-line:no-life-cycle-call
                testedService.ngOnDestroy();
            }
        });
        return function (overrides) {
            var defaults = { providers: [] };
            var providers = Object.assign(Object.assign({}, defaults), overrides).providers;
            if (providers && providers.length) {
                providers.forEach(function (provider) {
                    testing.TestBed.overrideProvider(provider.provide, provider);
                });
            }
            return new SpectatorService(testing.TestBed.inject ? testing.TestBed.inject(service) : testing.TestBed.get(service));
        };
    }

    var RouterStub = /** @class */ (function (_super) {
        __extends(RouterStub, _super);
        function RouterStub() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return RouterStub;
    }(router.Router));
    function isRouterStub(router) {
        return 'emitRouterEvent' in router;
    }

    /**
     * @publicApi
     */
    var SpectatorRouting = /** @class */ (function (_super) {
        __extends(SpectatorRouting, _super);
        function SpectatorRouting(fixture, debugElement, instance, router, activatedRouteStub) {
            var _this = _super.call(this, fixture, debugElement, instance, debugElement.nativeElement) || this;
            _this.router = router;
            _this.activatedRouteStub = activatedRouteStub;
            return _this;
        }
        /**
         * Simulates a route navigation by updating the Params, QueryParams and Data observable streams.
         */
        SpectatorRouting.prototype.triggerNavigation = function (options) {
            if (!this.checkStubPresent()) {
                return;
            }
            if (options && options.params) {
                this.activatedRouteStub.setParams(options.params);
            }
            if (options && options.queryParams) {
                this.activatedRouteStub.setQueryParams(options.queryParams);
            }
            if (options && options.data) {
                this.activatedRouteStub.setAllData(options.data);
            }
            if (options && options.fragment) {
                this.activatedRouteStub.setFragment(options.fragment);
            }
            this.triggerNavigationAndUpdate();
        };
        /**
         * Updates the route params and triggers a route navigation.
         */
        SpectatorRouting.prototype.setRouteParam = function (name, value) {
            if (this.checkStubPresent()) {
                this.activatedRouteStub.setParam(name, value);
                this.triggerNavigationAndUpdate();
            }
        };
        /**
         * Updates the route query params and triggers a route navigation.
         */
        SpectatorRouting.prototype.setRouteQueryParam = function (name, value) {
            if (this.checkStubPresent()) {
                this.activatedRouteStub.setQueryParam(name, value);
                this.triggerNavigationAndUpdate();
            }
        };
        /**
         * Updates the route data and triggers a route navigation.
         */
        SpectatorRouting.prototype.setRouteData = function (name, value) {
            if (this.checkStubPresent()) {
                this.activatedRouteStub.setData(name, value);
                this.triggerNavigationAndUpdate();
            }
        };
        /**
         * Updates the route fragment and triggers a route navigation.
         */
        SpectatorRouting.prototype.setRouteFragment = function (fragment) {
            if (this.checkStubPresent()) {
                this.activatedRouteStub.setFragment(fragment);
                this.triggerNavigationAndUpdate();
            }
        };
        /**
         * Updates the route url and triggers a route navigation.
         */
        SpectatorRouting.prototype.setRouteUrl = function (url) {
            if (this.checkStubPresent()) {
                this.activatedRouteStub.setUrl(url);
                this.triggerNavigationAndUpdate();
            }
        };
        /**
         * Emits a router event
         */
        SpectatorRouting.prototype.emitRouterEvent = function (event) {
            if (!isRouterStub(this.router)) {
                // tslint:disable-next-line:no-console
                console.warn('No stub for Router present. Set Spectator option "stubsEnabled" to true if you want to use this ' +
                    'helper, or use Router navigation to trigger events.');
                return;
            }
            this.router.emitRouterEvent(event);
        };
        SpectatorRouting.prototype.triggerNavigationAndUpdate = function () {
            this.activatedRouteStub.triggerNavigation();
            this.detectChanges();
        };
        SpectatorRouting.prototype.checkStubPresent = function () {
            if (!this.activatedRouteStub) {
                // tslint:disable-next-line:no-console
                console.warn('No stub for ActivatedRoute present. Set Spectator option "stubsEnabled" to true if you want to use this ' +
                    'helper, or use Router to trigger navigation.');
                return false;
            }
            return true;
        };
        return SpectatorRouting;
    }(Spectator));

    /**
     * @publicApi
     *
     * Utility class for stubbing ActivatedRoute of @angular/router
     */
    var ActivatedRouteStub = /** @class */ (function (_super) {
        __extends(ActivatedRouteStub, _super);
        function ActivatedRouteStub(options) {
            var _this = _super.call(this) || this;
            _this.testParams = {};
            _this.testQueryParams = {};
            _this.testData = {};
            _this.testFragment = null;
            _this.testUrl = [];
            _this.testRoot = null;
            _this.testParent = null;
            _this.testFirstChild = null;
            _this.testChildren = null;
            _this.paramsSubject = new rxjs.ReplaySubject(1);
            _this.queryParamsSubject = new rxjs.ReplaySubject(1);
            _this.dataSubject = new rxjs.ReplaySubject(1);
            _this.fragmentSubject = new rxjs.ReplaySubject(1);
            _this.urlSubject = new rxjs.ReplaySubject(1);
            if (options) {
                _this.testParams = options.params || {};
                _this.testQueryParams = options.queryParams || {};
                _this.testData = options.data || {};
                _this.testFragment = options.fragment || null;
                _this.testUrl = options.url || [];
                _this.testRoot = options.root || null;
                _this.testParent = options.parent || null;
                _this.testFirstChild = options.firstChild || null;
                _this.testChildren = options.children || null;
            }
            _this.params = _this.paramsSubject.asObservable();
            _this.queryParams = _this.queryParamsSubject.asObservable();
            _this.data = _this.dataSubject.asObservable();
            _this.fragment = _this.fragmentSubject.asObservable();
            _this.url = _this.urlSubject.asObservable();
            _this.snapshot = _this.buildSnapshot();
            _this.triggerNavigation();
            return _this;
        }
        Object.defineProperty(ActivatedRouteStub.prototype, "paramMap", {
            get: function () {
                return this.paramsSubject.asObservable().pipe(operators.map(function (params) { return router.convertToParamMap(params); }));
            },
            enumerable: false,
            configurable: true
        });
        ActivatedRouteStub.prototype.setParams = function (params) {
            this.testParams = params;
            this.snapshot = this.buildSnapshot();
        };
        ActivatedRouteStub.prototype.setParam = function (name, value) {
            var _a;
            this.testParams = Object.assign(Object.assign({}, this.testParams), (_a = {}, _a[name] = value, _a));
            this.snapshot = this.buildSnapshot();
        };
        ActivatedRouteStub.prototype.setQueryParams = function (queryParams) {
            this.testQueryParams = queryParams;
            this.snapshot = this.buildSnapshot();
        };
        ActivatedRouteStub.prototype.setQueryParam = function (name, value) {
            var _a;
            this.testQueryParams = Object.assign(Object.assign({}, this.testQueryParams), (_a = {}, _a[name] = value, _a));
            this.snapshot = this.buildSnapshot();
        };
        ActivatedRouteStub.prototype.setAllData = function (data) {
            this.testData = data;
            this.snapshot = this.buildSnapshot();
        };
        ActivatedRouteStub.prototype.setData = function (name, value) {
            var _a;
            this.testData = Object.assign(Object.assign({}, this.testData), (_a = {}, _a[name] = value, _a));
            this.snapshot = this.buildSnapshot();
        };
        ActivatedRouteStub.prototype.setFragment = function (fragment) {
            this.testFragment = fragment;
            this.snapshot = this.buildSnapshot();
        };
        ActivatedRouteStub.prototype.setUrl = function (url) {
            this.testUrl = url;
            this.snapshot = this.buildSnapshot();
        };
        Object.defineProperty(ActivatedRouteStub.prototype, "root", {
            get: function () {
                return this.testRoot || this;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ActivatedRouteStub.prototype, "parent", {
            get: function () {
                return this.testParent || null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ActivatedRouteStub.prototype, "children", {
            get: function () {
                return this.testChildren || [this];
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ActivatedRouteStub.prototype, "firstChild", {
            get: function () {
                return this.testFirstChild || null;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Simulates a route navigation by updating the Params, QueryParams and Data observable streams.
         */
        ActivatedRouteStub.prototype.triggerNavigation = function () {
            this.paramsSubject.next(this.testParams);
            this.queryParamsSubject.next(this.testQueryParams);
            this.dataSubject.next(this.testData);
            this.fragmentSubject.next(this.testFragment);
            this.urlSubject.next(this.testUrl);
        };
        ActivatedRouteStub.prototype.toString = function () {
            return 'activatedRouteStub';
        };
        ActivatedRouteStub.prototype.buildSnapshot = function () {
            var snapshot = new router.ActivatedRouteSnapshot();
            snapshot.params = this.testParams;
            snapshot.queryParams = this.testQueryParams;
            snapshot.data = this.testData;
            snapshot.fragment = this.testFragment;
            snapshot.url = this.testUrl;
            return snapshot;
        };
        return ActivatedRouteStub;
    }(router.ActivatedRoute));

    // tslint:disable
    var RouterLinkDirectiveStub = /** @class */ (function () {
        function RouterLinkDirectiveStub() {
            this.navigatedTo = null;
        }
        RouterLinkDirectiveStub.prototype.onClick = function () {
            this.navigatedTo = this.routerLink;
            return true;
        };
        return RouterLinkDirectiveStub;
    }());
    RouterLinkDirectiveStub.decorators = [
        { type: core.Directive, args: [{
                    selector: '[routerLink]',
                    providers: [
                        {
                            provide: router.RouterLink,
                            useExisting: RouterLinkDirectiveStub
                        }
                    ]
                },] }
    ];
    RouterLinkDirectiveStub.propDecorators = {
        routerLink: [{ type: core.Input }],
        onClick: [{ type: core.HostListener, args: ['click',] }]
    };
    /*
      This is an unused module to resolve the ng build error:
        'Cannot determine the module for class RouterLinkDirectiveStub'

      Reference: https://github.com/angular/issues/13590
    */
    var RouterLinkDirectiveStubModule = /** @class */ (function () {
        function RouterLinkDirectiveStubModule() {
        }
        return RouterLinkDirectiveStubModule;
    }());
    RouterLinkDirectiveStubModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [RouterLinkDirectiveStub]
                },] }
    ];

    /**
     * @internal
     */
    function initialRoutingModule(options) {
        var moduleMetadata = initialSpectatorModule(options);
        if (options.mockRouterLinks && options.stubsEnabled) {
            moduleMetadata.declarations.push(RouterLinkDirectiveStub);
        }
        if (options.stubsEnabled) {
            moduleMetadata.providers.push(options.mockProvider(RouterStub, {
                events: new rxjs.Subject(),
                emitRouterEvent: function (event) {
                    this.events.next(event);
                }
            }), {
                provide: router.Router,
                useExisting: RouterStub
            });
            moduleMetadata.providers.push({
                provide: ActivatedRouteStub,
                useValue: new ActivatedRouteStub({
                    params: options.params,
                    queryParams: options.queryParams,
                    data: options.data
                })
            }, {
                provide: router.ActivatedRoute,
                useExisting: ActivatedRouteStub
            });
        }
        else {
            moduleMetadata.imports.push(testing$2.RouterTestingModule.withRoutes(options.routes));
        }
        return moduleMetadata;
    }

    var ɵ0$2 = {};
    var defaultRoutingOptions = Object.assign(Object.assign({}, getSpectatorDefaultOptions()), { params: {}, queryParams: {}, data: ɵ0$2, fragment: null, mockRouterLinks: true, stubsEnabled: true, routes: [], url: [], root: null, parent: null, children: null, firstChild: null });
    /**
     * @internal
     */
    function getRoutingDefaultOptions(overrides) {
        return merge(defaultRoutingOptions, overrides);
    }

    /**
     * @publicApi
     */
    function createRoutingFactory(typeOrOptions) {
        var options = isType(typeOrOptions)
            ? getRoutingDefaultOptions({ component: typeOrOptions })
            : getRoutingDefaultOptions(typeOrOptions);
        var moduleMetadata = initialRoutingModule(options);
        beforeEach(testing.async(function () {
            addMatchers(customMatchers);
            testing.TestBed.configureTestingModule(moduleMetadata);
            overrideModules(options);
            overrideComponentIfProviderOverridesSpecified(options);
            testing.TestBed.compileComponents();
        }));
        return function (overrides) {
            var defaults = {
                props: {},
                detectChanges: true,
                providers: []
            };
            var _a = Object.assign(Object.assign({}, defaults), overrides), detectChanges = _a.detectChanges, props = _a.props, providers = _a.providers;
            if (providers && providers.length) {
                providers.forEach(function (provider) {
                    testing.TestBed.overrideProvider(provider.provide, provider);
                });
            }
            var _b = Object.assign(Object.assign({}, options), overrides), params = _b.params, queryParams = _b.queryParams, data = _b.data, fragment = _b.fragment, url = _b.url, root = _b.root, parent = _b.parent, children = _b.children, firstChild = _b.firstChild;
            testing.TestBed.overrideProvider(router.ActivatedRoute, {
                useValue: new ActivatedRouteStub({ params: params, queryParams: queryParams, data: data, fragment: fragment, url: url, root: root, parent: parent, children: children, firstChild: firstChild })
            });
            var ngZone = testing.TestBed.inject ? testing.TestBed.inject(core.NgZone) : testing.TestBed.get(core.NgZone);
            return ngZone.run(function () {
                var spectator = createSpectatorRouting(options, props);
                spectator.router.initialNavigation();
                if (options.detectChanges && detectChanges) {
                    spectator.detectChanges();
                }
                return spectator;
            });
        };
    }
    function createSpectatorRouting(options, props) {
        var fixture = testing.TestBed.createComponent(options.component);
        var debugElement = fixture.debugElement;
        var component = setProps(fixture.componentInstance, props);
        /**
         * Back compatibility, angular under 9 version doesnt have a inject function
         */
        if (!testing.TestBed.inject) {
            return new SpectatorRouting(fixture, debugElement, component, testing.TestBed.get(router.Router), testing.TestBed.get(router.ActivatedRoute));
        }
        return new SpectatorRouting(fixture, debugElement, component, testing.TestBed.inject(router.Router), testing.TestBed.inject(router.ActivatedRoute));
    }

    (function (HttpMethod) {
        HttpMethod["GET"] = "GET";
        HttpMethod["POST"] = "POST";
        HttpMethod["DELETE"] = "DELETE";
        HttpMethod["PUT"] = "PUT";
        HttpMethod["PATCH"] = "PATCH";
        HttpMethod["HEAD"] = "HEAD";
        HttpMethod["JSONP"] = "JSONP";
        HttpMethod["OPTIONS"] = "OPTIONS";
    })(exports.HttpMethod || (exports.HttpMethod = {}));
    /**
     * @publicApi
     */
    var SpectatorHttp = /** @class */ (function (_super) {
        __extends(SpectatorHttp, _super);
        function SpectatorHttp(service, httpClient, controller) {
            var _this = _super.call(this) || this;
            _this.service = service;
            _this.httpClient = httpClient;
            _this.controller = controller;
            // small workaround to prevent issues if destructuring SpectatorHttp, which was common in Spectator 3
            // remove in v5?
            _this.expectOne = _this.expectOne.bind(_this);
            _this.expectConcurrent = _this.expectConcurrent.bind(_this);
            return _this;
        }
        SpectatorHttp.prototype.expectOne = function (url, method) {
            expect(true).toBe(true); // workaround to avoid `Spec has no expectations` https://github.com/NetanelBasal/spectator/issues/75
            var req = this.controller.expectOne({
                url: url,
                method: method
            });
            // assert that there are no outstanding requests.
            this.controller.verify();
            return req;
        };
        SpectatorHttp.prototype.expectConcurrent = function (expectations) {
            var _this = this;
            var requests = expectations.map(function (expectation) {
                return _this.controller.expectOne({
                    url: expectation.url,
                    method: expectation.method
                });
            });
            this.controller.verify();
            return requests;
        };
        SpectatorHttp.prototype.flushAll = function (requests, args) {
            requests.forEach(function (request, idx) {
                request.flush(args[idx]);
            });
        };
        return SpectatorHttp;
    }(BaseSpectator));

    /**
     * @internal
     */
    function initialHttpModule(options) {
        var moduleMetadata = initialModule(options);
        moduleMetadata.providers.push(options.service);
        moduleMetadata.imports.push(testing$3.HttpClientTestingModule);
        return moduleMetadata;
    }

    var defaultHttpOptions = Object.assign({}, getDefaultBaseOptions());
    /**
     * @internal
     */
    function getDefaultHttpOptions(overrides) {
        return merge(defaultHttpOptions, overrides);
    }

    /**
     * @publicApi
     */
    function createHttpFactory(typeOrOptions) {
        var service = isType(typeOrOptions) ? typeOrOptions : typeOrOptions.service;
        var options = isType(typeOrOptions) ? getDefaultHttpOptions({ service: service }) : getDefaultHttpOptions(typeOrOptions);
        var moduleMetadata = initialHttpModule(options);
        beforeEach(function () {
            testing.TestBed.configureTestingModule(moduleMetadata);
            overrideModules(options);
        });
        afterEach(function () {
            if (testing.TestBed.inject) {
                testing.TestBed.inject(testing$3.HttpTestingController).verify();
            }
            else {
                testing.TestBed.get(testing$3.HttpTestingController).verify();
            }
        });
        return function (overrides) {
            var defaults = { providers: [] };
            var providers = Object.assign(Object.assign({}, defaults), overrides).providers;
            if (providers && providers.length) {
                providers.forEach(function (provider) {
                    testing.TestBed.overrideProvider(provider.provide, provider);
                });
            }
            /**
             * Back compatibility, angular under 9 version doesnt have a inject function
             */
            if (!testing.TestBed.inject) {
                return new SpectatorHttp(testing.TestBed.get(service), testing.TestBed.get(http.HttpClient), testing.TestBed.get(testing$3.HttpTestingController));
            }
            return new SpectatorHttp(testing.TestBed.inject(service), testing.TestBed.inject(http.HttpClient), testing.TestBed.inject(testing$3.HttpTestingController));
        };
    }

    /**
     * @publicApi
     */
    var SpectatorPipe = /** @class */ (function (_super) {
        __extends(SpectatorPipe, _super);
        function SpectatorPipe(hostComponent, fixture, debugElement, element) {
            var _this = _super.call(this) || this;
            _this.hostComponent = hostComponent;
            _this.fixture = fixture;
            _this.debugElement = debugElement;
            _this.element = element;
            return _this;
        }
        SpectatorPipe.prototype.detectChanges = function () {
            this.fixture.detectChanges();
        };
        SpectatorPipe.prototype.setHostInput = function (input, value) {
            setProps(this.hostComponent, input, value, false);
            this.detectChanges();
        };
        return SpectatorPipe;
    }(BaseSpectator));

    /**
     * @internal
     */
    function initialSpectatorPipeModule(options) {
        var moduleMetadata = initialModule(options);
        moduleMetadata.declarations.push(options.pipe);
        moduleMetadata.declarations.push(options.host);
        return moduleMetadata;
    }

    var defaultSpectatorPipeOptions = Object.assign(Object.assign({}, getDefaultBaseOptions()), { host: HostComponent, detectChanges: true, template: '' });
    /**
     * @internal
     */
    function getSpectatorPipeDefaultOptions(overrides) {
        return merge(defaultSpectatorPipeOptions, overrides);
    }

    /**
     * @publicApi
     */
    function createPipeFactory(typeOrOptions) {
        var options = isType(typeOrOptions)
            ? getSpectatorPipeDefaultOptions({ pipe: typeOrOptions })
            : getSpectatorPipeDefaultOptions(typeOrOptions);
        var moduleMetadata = initialSpectatorPipeModule(options);
        beforeEach(testing.async(function () {
            addMatchers(customMatchers);
            testing.TestBed.configureTestingModule(moduleMetadata);
            overrideModules(options);
        }));
        return function (templateOrOverrides, overrides) {
            var defaults = {
                hostProps: {},
                detectChanges: true,
                providers: []
            };
            var resolvedOverrides = typeof templateOrOverrides === 'object' ? templateOrOverrides : overrides;
            var _a = Object.assign(Object.assign({}, defaults), resolvedOverrides), detectChanges = _a.detectChanges, hostProps = _a.hostProps, providers = _a.providers;
            var template = typeof templateOrOverrides === 'string' ? templateOrOverrides : options.template;
            if (providers && providers.length) {
                providers.forEach(function (provider) {
                    testing.TestBed.overrideProvider(provider.provide, provider);
                });
            }
            if (template) {
                testing.TestBed.overrideModule(testing$1.BrowserDynamicTestingModule, {
                    set: {
                        entryComponents: moduleMetadata.entryComponents
                    }
                }).overrideComponent(options.host, {
                    set: { template: template }
                });
            }
            var spectator = createSpectatorPipe(options, hostProps);
            if (options.detectChanges && detectChanges) {
                spectator.detectChanges();
            }
            return spectator;
        };
    }
    function createSpectatorPipe(options, hostProps) {
        var hostFixture = testing.TestBed.createComponent(options.host);
        var debugElement = hostFixture.debugElement;
        var hostComponent = setProps(hostFixture.componentInstance, hostProps);
        return new SpectatorPipe(hostComponent, hostFixture, hostFixture.debugElement, debugElement.nativeElement);
    }

    function MockComponentDeprecated(options) {
        var metadata = {
            selector: options.selector,
            template: options.template || '',
            inputs: options.inputs,
            outputs: options.outputs || [],
            exportAs: options.exportAs || ''
        };
        var Mock = /** @class */ (function () {
            function Mock() {
            }
            return Mock;
        }());
        metadata.outputs.forEach(function (method) {
            Mock.prototype[method] = new core.EventEmitter();
        });
        return core.Component(metadata)(Mock);
    }
    function MockDirectiveDeprecated(options) {
        var metadata = {
            selector: options.selector,
            inputs: options.inputs,
            outputs: options.outputs || [],
            exportAs: options.exportAs || ''
        };
        var Mock = /** @class */ (function () {
            function Mock() {
            }
            return Mock;
        }());
        metadata.outputs.forEach(function (method) {
            Mock.prototype[method] = new core.EventEmitter();
        });
        return core.Directive(metadata)(Mock);
    }

    /// <reference path="./lib/matchers-types.ts" />

    /**
     * Generated bundle index. Do not edit.
     */

    exports.ActivatedRouteStub = ActivatedRouteStub;
    exports.DOMSelector = DOMSelector;
    exports.HostComponent = HostComponent;
    exports.HostModule = HostModule;
    exports.MockComponentDeprecated = MockComponentDeprecated;
    exports.MockDirectiveDeprecated = MockDirectiveDeprecated;
    exports.Spectator = Spectator;
    exports.SpectatorDirective = SpectatorDirective;
    exports.SpectatorHost = SpectatorHost;
    exports.SpectatorHttp = SpectatorHttp;
    exports.SpectatorPipe = SpectatorPipe;
    exports.SpectatorRouting = SpectatorRouting;
    exports.SpectatorService = SpectatorService;
    exports.byAltText = byAltText;
    exports.byLabel = byLabel;
    exports.byPlaceholder = byPlaceholder;
    exports.byRole = byRole;
    exports.byTestId = byTestId;
    exports.byText = byText;
    exports.byTextContent = byTextContent;
    exports.byTitle = byTitle;
    exports.byValue = byValue;
    exports.createComponentFactory = createComponentFactory;
    exports.createDirectiveFactory = createDirectiveFactory;
    exports.createFakeEvent = createFakeEvent;
    exports.createHostFactory = createHostFactory;
    exports.createHttpFactory = createHttpFactory;
    exports.createKeyboardEvent = createKeyboardEvent;
    exports.createMouseEvent = createMouseEvent;
    exports.createPipeFactory = createPipeFactory;
    exports.createRoutingFactory = createRoutingFactory;
    exports.createServiceFactory = createServiceFactory;
    exports.createSpyObject = createSpyObject;
    exports.createTouchEvent = createTouchEvent;
    exports.defineGlobalsInjections = defineGlobalsInjections;
    exports.dispatchEvent = dispatchEvent;
    exports.dispatchFakeEvent = dispatchFakeEvent;
    exports.dispatchKeyboardEvent = dispatchKeyboardEvent;
    exports.dispatchMouseEvent = dispatchMouseEvent;
    exports.dispatchTouchEvent = dispatchTouchEvent;
    exports.doesServiceImplementsOnDestroy = doesServiceImplementsOnDestroy;
    exports.initialSpectatorDirectiveModule = initialSpectatorDirectiveModule;
    exports.initialSpectatorModule = initialSpectatorModule;
    exports.initialSpectatorPipeModule = initialSpectatorPipeModule;
    exports.initialSpectatorWithHostModule = initialSpectatorWithHostModule;
    exports.installProtoMethods = installProtoMethods;
    exports.isHTMLOptionElementArray = isHTMLOptionElementArray;
    exports.isNumber = isNumber;
    exports.isObject = isObject;
    exports.isString = isString;
    exports.isType = isType;
    exports.mockProvider = mockProvider;
    exports.toBeChecked = toBeChecked;
    exports.toBeDisabled = toBeDisabled;
    exports.toBeEmpty = toBeEmpty;
    exports.toBeFocused = toBeFocused;
    exports.toBeHidden = toBeHidden;
    exports.toBeMatchedBy = toBeMatchedBy;
    exports.toBeSelected = toBeSelected;
    exports.toBeVisible = toBeVisible;
    exports.toContainProperty = toContainProperty;
    exports.toContainText = toContainText;
    exports.toContainValue = toContainValue;
    exports.toExist = toExist;
    exports.toHaveAttribute = toHaveAttribute;
    exports.toHaveClass = toHaveClass;
    exports.toHaveData = toHaveData;
    exports.toHaveDescendant = toHaveDescendant;
    exports.toHaveDescendantWithText = toHaveDescendantWithText;
    exports.toHaveExactText = toHaveExactText;
    exports.toHaveId = toHaveId;
    exports.toHaveLength = toHaveLength;
    exports.toHaveProperty = toHaveProperty;
    exports.toHaveSelectedOptions = toHaveSelectedOptions;
    exports.toHaveStyle = toHaveStyle;
    exports.toHaveText = toHaveText;
    exports.toHaveValue = toHaveValue;
    exports.typeInElement = typeInElement;
    exports.ɵ0 = ɵ0$1;
    exports.ɵ1 = ɵ1;
    exports.ɵ10 = ɵ10;
    exports.ɵ11 = ɵ11;
    exports.ɵ12 = ɵ12;
    exports.ɵ13 = ɵ13;
    exports.ɵ14 = ɵ14;
    exports.ɵ15 = ɵ15;
    exports.ɵ16 = ɵ16;
    exports.ɵ17 = ɵ17;
    exports.ɵ18 = ɵ18;
    exports.ɵ19 = ɵ19;
    exports.ɵ2 = ɵ2;
    exports.ɵ20 = ɵ20;
    exports.ɵ21 = ɵ21;
    exports.ɵ22 = ɵ22;
    exports.ɵ23 = ɵ23;
    exports.ɵ24 = ɵ24;
    exports.ɵ25 = ɵ25;
    exports.ɵ26 = ɵ26;
    exports.ɵ27 = ɵ27;
    exports.ɵ28 = ɵ28;
    exports.ɵ3 = ɵ3;
    exports.ɵ4 = ɵ4;
    exports.ɵ5 = ɵ5;
    exports.ɵ6 = ɵ6;
    exports.ɵ7 = ɵ7;
    exports.ɵ8 = ɵ8;
    exports.ɵ9 = ɵ9;
    exports.ɵa = DomSpectator;
    exports.ɵb = BaseSpectator;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ngneat-spectator.umd.js.map
