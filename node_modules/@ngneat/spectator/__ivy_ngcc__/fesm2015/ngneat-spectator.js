import { SimpleChange, ChangeDetectorRef, DebugElement, ElementRef, NO_ERRORS_SCHEMA, Component, NgModule, Directive, Input, HostListener, NgZone, EventEmitter } from '@angular/core';
import { Observable, ReplaySubject, Subject } from 'rxjs';
import { TestBed, tick, async } from '@angular/core/testing';
import { By } from '@angular/platform-browser';
import { queries, getDefaultNormalizer } from '@testing-library/dom';
import { BrowserDynamicTestingModule } from '@angular/platform-browser-dynamic/testing';
import $ from 'jquery';
import { NoopAnimationsModule } from '@angular/platform-browser/animations';
import { Router, ActivatedRoute, convertToParamMap, ActivatedRouteSnapshot, RouterLink } from '@angular/router';
import { map } from 'rxjs/operators';
import { RouterTestingModule } from '@angular/router/testing';
import { HttpClient } from '@angular/common/http';
import { HttpClientTestingModule, HttpTestingController } from '@angular/common/http/testing';

import * as ɵngcc0 from '@angular/core';
class DOMSelector {
    // Wrap selector functions in a class to make reflection easier in getChild
    constructor(execute) {
        this.execute = execute;
    }
}
const byLabel = (matcher, options) => new DOMSelector(el => queries.queryAllByLabelText(el, matcher, options));
const byPlaceholder = (matcher, options) => new DOMSelector(el => queries.queryAllByPlaceholderText(el, matcher, options));
const byText = (matcher, options) => new DOMSelector(el => queries.queryAllByText(el, matcher, options));
const byTextContent = (matcher, options) => {
    let textContentMatcher;
    const normalizer = (options === null || options === void 0 ? void 0 : options.normalizer) || getDefaultNormalizer(options);
    const getTextContent = (elem) => { var _a; return normalizer((_a = elem.textContent) !== null && _a !== void 0 ? _a : ''); };
    if (typeof matcher === 'string') {
        textContentMatcher = (_, elem) => {
            if ((options === null || options === void 0 ? void 0 : options.exact) === false) {
                return (getTextContent(elem)
                    .toLowerCase()
                    .indexOf(matcher.toLowerCase()) >= 0);
            }
            return getTextContent(elem) === matcher;
        };
    }
    else if (matcher instanceof RegExp) {
        textContentMatcher = (_, elem) => matcher.test(getTextContent(elem));
    }
    else {
        textContentMatcher = (_, elem) => matcher(getTextContent(elem), elem);
    }
    return new DOMSelector(el => queries.queryAllByText(el, textContentMatcher, options));
};
const byAltText = (matcher, options) => new DOMSelector(el => queries.queryAllByAltText(el, matcher, options));
const byTitle = (matcher, options) => new DOMSelector(el => queries.queryAllByTitle(el, matcher, options));
const byTestId = (matcher, options) => new DOMSelector(el => queries.queryAllByTestId(el, matcher, options));
const byValue = (matcher, options) => new DOMSelector(el => queries.queryAllByDisplayValue(el, matcher, options));
const byRole = (matcher, options) => new DOMSelector(el => queries.queryAllByRole(el, matcher, options));

function doesServiceImplementsOnDestroy(testedService) {
    return 'ngOnDestroy' in testedService && typeof testedService['ngOnDestroy'] === 'function';
}
function isString(value) {
    return typeof value === 'string';
}
function isNumber(value) {
    return typeof value === 'number';
}
function isType(v) {
    return typeof v === 'function';
}
function isHTMLOptionElementArray(value) {
    return Array.isArray(value) && !!value.length && value.every(item => item instanceof HTMLOptionElement);
}
function isObject(v) {
    return v && typeof v === 'object';
}

function getChildren(debugElementRoot) {
    return (directiveOrSelector, options = { root: false, read: undefined }) => {
        if (directiveOrSelector instanceof DOMSelector) {
            return directiveOrSelector.execute(debugElementRoot.nativeElement);
        }
        const debugElements = debugElementRoot.queryAll(isString(directiveOrSelector) ? By.css(directiveOrSelector) : By.directive(directiveOrSelector));
        if (options.read) {
            return debugElements.map(debug => debug.injector.get(options.read));
        }
        if (isString(directiveOrSelector)) {
            return debugElements.map(debug => debug.nativeElement);
        }
        return debugElements.map(debug => debug.injector.get(directiveOrSelector));
    };
}
function setProps(instance, keyOrKeyValues, value, firstChange = true) {
    var _a;
    const changes = {};
    const update = (key, newValue) => {
        if (instance[key] !== newValue) {
            changes[key] = new SimpleChange(instance[key], newValue, firstChange);
        }
        instance[key] = newValue;
    };
    if (isString(keyOrKeyValues)) {
        update(keyOrKeyValues, value);
    }
    else {
        // tslint:disable-next-line:forin
        for (const p in keyOrKeyValues) {
            update(p, keyOrKeyValues[p]);
        }
    }
    if (Object.keys(changes).length) {
        // tslint:disable-next-line:no-life-cycle-call
        (_a = instance.ngOnChanges) === null || _a === void 0 ? void 0 : _a.call(instance, changes);
    }
    return instance;
}

const parseKeyOptions = (keyOrKeyCode) => {
    if (isNumber(keyOrKeyCode) && keyOrKeyCode) {
        return { key: false, keyCode: keyOrKeyCode, modifiers: {} };
    }
    if (isString(keyOrKeyCode) && keyOrKeyCode) {
        return parseKey(keyOrKeyCode);
    }
    if (isObject(keyOrKeyCode)) {
        const parsedKey = parseKey(keyOrKeyCode.key);
        return Object.assign(Object.assign({}, parsedKey), { keyCode: keyOrKeyCode.keyCode });
    }
    throw new Error('keyboard.pressKey() requires a valid key or keyCode');
};
const parseKey = (keyStr) => {
    if (keyStr.indexOf('.') < 0 || '.' === keyStr) {
        return { key: keyStr, keyCode: false, modifiers: {} };
    }
    const keyParts = keyStr.split('.');
    const key = keyParts.pop();
    const modifiers = keyParts.reduce((mods, part) => {
        switch (part) {
            case 'control':
            case 'ctrl':
                mods.control = true;
                return mods;
            case 'shift':
                mods.shift = true;
                return mods;
            case 'alt':
                mods.alt = true;
                return mods;
            case 'meta':
            case 'cmd':
            case 'win':
                mods.meta = true;
                return mods;
            default:
                throw new Error(`invalid key modifier: ${part ? part : 'undefined'}, keyStr: ${keyStr}`);
        }
    }, { alt: false, control: false, shift: false, meta: false });
    return { key, keyCode: false, modifiers };
};
const ɵ0 = parseKey;

/**
 * Credit - Angular Material
 */
/** Creates a browser MouseEvent with the specified options. */
function createMouseEvent(type, x = 0, y = 0, button = 0) {
    const event = document.createEvent('MouseEvent');
    event.initMouseEvent(type, true, false, window, 0, x, y, x, y, false, false, false, false, button, null);
    // `initMouseEvent` doesn't allow us to pass the `buttons` and
    // defaults it to 0 which looks like a fake event.
    Object.defineProperty(event, 'buttons', { get: () => 1 });
    return event;
}
/**
 * Creates a browser TouchEvent with the specified pointer coordinates.
 */
function createTouchEvent(type, pageX = 0, pageY = 0) {
    // In favor of creating events that work for most of the browsers, the event is created
    // as a basic UI Event. The necessary details for the event will be set manually.
    const event = new UIEvent(type, {
        bubbles: true,
        cancelable: true,
        view: window,
        detail: 0
    });
    // Most of the browsers don't have a "initTouchEvent" method that can be used to define
    // the touch details.
    Object.defineProperties(event, {
        touches: { value: [{ pageX, pageY }] }
    });
    return event;
}
/** Dispatches a keydown event from an element. */
function createKeyboardEvent(type, keyOrKeyCode, target) {
    const { key, keyCode, modifiers } = parseKeyOptions(keyOrKeyCode);
    const event = document.createEvent('KeyboardEvent');
    const originalPreventDefault = event.preventDefault;
    // Firefox does not support `initKeyboardEvent`, but supports `initKeyEvent`.
    if (event.initKeyEvent) {
        event.initKeyEvent(type, true, true, window, modifiers.control, modifiers.alt, modifiers.shift, modifiers.meta, keyCode);
    }
    else {
        // `initKeyboardEvent` expects to receive modifiers as a whitespace-delimited string
        // See https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/initKeyboardEvent
        const modifiersStr = (modifiers.control
            ? 'Control '
            : '' + modifiers.alt
                ? 'Alt '
                : '' + modifiers.shift
                    ? 'Shift '
                    : '' + modifiers.meta
                        ? 'Meta'
                        : '').trim();
        event.initKeyboardEvent(type, true /* canBubble */, true /* cancelable */, window /* view */, 0 /* char */, key /* key */, 0 /* location */, modifiersStr /* modifiersList */, false /* repeat */);
    }
    // Webkit Browsers don't set the keyCode when calling the init function.
    // See related bug https://bugs.webkit.org/show_bug.cgi?id=16735
    Object.defineProperties(event, {
        keyCode: { get: () => keyCode },
        key: { get: () => key },
        target: { get: () => target },
        altKey: { get: () => !!modifiers.alt },
        ctrlKey: { get: () => !!modifiers.control },
        shiftKey: { get: () => !!modifiers.shift },
        metaKey: { get: () => !!modifiers.meta }
    });
    // IE won't set `defaultPrevented` on synthetic events so we need to do it manually.
    // tslint:disable-next-line
    event.preventDefault = function () {
        Object.defineProperty(event, 'defaultPrevented', { configurable: true, get: () => true });
        return originalPreventDefault.apply(this, arguments);
    };
    return event;
}
/** Creates a fake event object with any desired event type. */
function createFakeEvent(type, canBubble = false, cancelable = true) {
    const event = document.createEvent('Event');
    event.initEvent(type, canBubble, cancelable);
    return event;
}

/**
 * Credit - Angular Material
 */
/**
 * Utility to dispatch any event on a Node.
 *
 * @publicApi
 */
function dispatchEvent(node, event) {
    node.dispatchEvent(event);
    return event;
}
/**
 * Shorthand to dispatch a fake event on a specified node.
 *
 * dispatchFakeEvent(element, 'mousedown');
 *
 * @publicApi
 */
function dispatchFakeEvent(node, type, canBubble) {
    return dispatchEvent(node, createFakeEvent(type, canBubble));
}
/**
 * Shorthand to dispatch a keyboard event with a specified key.
 *
 *  dispatchKeyboardEvent(calendarBodyEl, 'keydown', 'LEFT_ARROW');
 *
 *  @publicApi
 */
function dispatchKeyboardEvent(node, type, keyOrKeyCode, target) {
    return dispatchEvent(node, createKeyboardEvent(type, keyOrKeyCode, target));
}
/**
 * Shorthand to dispatch a mouse event on the specified coordinates.
 *
 *  dispatchMouseEvent(rippleTarget, 'mousedown', 50, 75);
 *  dispatchMouseEvent(rippleTarget, 'mouseup');
 *
 *  @publicApi
 */
function dispatchMouseEvent(node, type, x = 0, y = 0, event = createMouseEvent(type, x, y)) {
    return dispatchEvent(node, event);
}
/**
 * Shorthand to dispatch a touch event on the specified coordinates.
 *
 * dispatchTouchEvent(rippleTarget, 'touchstart');
 *
 * @publicApi
 */
function dispatchTouchEvent(node, type, x = 0, y = 0) {
    return dispatchEvent(node, createTouchEvent(type, x, y));
}

/**
 * Patches an elements focus and blur methods to emit events consistently and predictably.
 * This is necessary, because some browsers, like IE11, will call the focus handlers asynchronously,
 * while others won't fire them at all if the browser window is not focused.
 *
 * patchElementFocus(triggerEl);
 */
function patchElementFocus(element) {
    element.focus = () => dispatchFakeEvent(element, 'focus');
    element.blur = () => dispatchFakeEvent(element, 'blur');
}

/**
 * Focuses an input or textarea, sets its value and dispatches
 * the `input` or `textarea` event, simulating the user typing.
 * @param value Value to be set on the input.
 * @param element Element onto which to set the value.
 *
 * typeInElement('al', input);
 */
function typeInElement(value, element) {
    if (!(element instanceof HTMLInputElement) && !(element instanceof HTMLTextAreaElement)) {
        return;
    }
    element.focus();
    element.value = value;
    dispatchFakeEvent(element, 'input', true);
}

/**
 * Focuses a select element, selects the correct options and dispatches
 * the `change` event, simulating the user selecting an option
 * @param options Options to be selected.
 * @param element Element onto which to select the options.
 * @param config Object with extra config to dispatch change event when option selected
 *
 * selectOption('al' | ['al', 'ab'], select, config);
 */
function selectOption(options, element, config) {
    if (!(element instanceof HTMLSelectElement)) {
        return;
    }
    element.focus();
    if (isString(options)) {
        const option = element.querySelector(`option[value="${options}"]`);
        if (!option) {
            return;
        }
        setOptionSelected(option, element, config);
    }
    else if (options instanceof HTMLOptionElement) {
        setOptionSelected(options, element, config);
    }
    else {
        if (!element.multiple) {
            return;
        }
        if (isHTMLOptionElementArray(options)) {
            options.forEach(option => setOptionSelected(option, element, config));
        }
        else {
            element.querySelectorAll('option').forEach(opt => {
                if (options.includes(opt.value)) {
                    setOptionSelected(opt, element, config);
                }
            });
        }
    }
}
/**
 * Set the option in the HTMLSelectElement to selected
 * @param option HTMLOptionElement to select
 * @param select HTMLSelectElement to add the options to
 * @param config Object with extra config to dispatch change event when option selected
 *
 * setOptionSelected(option, element, config);
 */
function setOptionSelected(option, select, config) {
    option.selected = true;
    if (config.emitEvents) {
        dispatchFakeEvent(select, 'change', true);
    }
}

/**
 * @internal
 */
class BaseSpectator {
    inject(token) {
        return TestBed.inject ? TestBed.inject(token) : TestBed.get(token);
    }
}

const KEY_UP = 'keyup';
/**
 * @internal
 */
class DomSpectator extends BaseSpectator {
    constructor(fixture, debugElement, instance, element) {
        super();
        this.fixture = fixture;
        this.debugElement = debugElement;
        this.instance = instance;
        this.element = element;
    }
    inject(token) {
        return super.inject(token);
    }
    detectChanges() {
        this.fixture.detectChanges();
    }
    query(directiveOrSelector, options) {
        if ((options || {}).root) {
            if (isString(directiveOrSelector)) {
                return document.querySelector(directiveOrSelector);
            }
            if (directiveOrSelector instanceof DOMSelector) {
                return directiveOrSelector.execute(document)[0] || null;
            }
        }
        return getChildren(this.debugElement)(directiveOrSelector, options)[0] || null;
    }
    queryAll(directiveOrSelector, options) {
        if ((options || {}).root) {
            if (isString(directiveOrSelector)) {
                return Array.from(document.querySelectorAll(directiveOrSelector));
            }
            if (directiveOrSelector instanceof DOMSelector) {
                return directiveOrSelector.execute(document);
            }
        }
        return getChildren(this.debugElement)(directiveOrSelector, options);
    }
    queryLast(directiveOrSelector, options) {
        let result = [];
        if ((options || {}).root) {
            if (isString(directiveOrSelector)) {
                result = Array.from(document.querySelectorAll(directiveOrSelector));
            }
            if (directiveOrSelector instanceof DOMSelector) {
                result = directiveOrSelector.execute(document);
            }
        }
        else {
            result = getChildren(this.debugElement)(directiveOrSelector, options);
        }
        if (result && result.length) {
            return result[result.length - 1];
        }
        return null;
    }
    setInput(input, value) {
        setProps(this.instance, input, value, false);
        this.debugElement.injector.get(ChangeDetectorRef).detectChanges();
    }
    output(output) {
        const observable = this.instance[output];
        if (!(observable instanceof Observable)) {
            throw new Error(`${output} is not an @Output`);
        }
        return observable;
    }
    tick(millis) {
        tick(millis);
        this.detectChanges();
    }
    click(selector = this.element) {
        const element = this.getNativeElement(selector);
        if (!(element instanceof HTMLElement)) {
            throw new Error(`Cannot click: ${selector} is not a HTMLElement`);
        }
        element.click();
        this.detectChanges();
    }
    blur(selector = this.element) {
        const element = this.getNativeElement(selector);
        if (!(element instanceof HTMLElement)) {
            throw new Error(`Cannot blur: ${selector} is not a HTMLElement`);
        }
        patchElementFocus(element);
        element.blur();
        this.detectChanges();
    }
    focus(selector = this.element) {
        const element = this.getNativeElement(selector);
        if (!(element instanceof HTMLElement)) {
            throw new Error(`Cannot focus: ${selector} is not a HTMLElement`);
        }
        patchElementFocus(element);
        element.focus();
        this.detectChanges();
    }
    dispatchMouseEvent(selector = this.element, type, x = 0, y = 0, event = createMouseEvent(type, x, y)) {
        const element = this.getNativeElement(selector);
        if (!(element instanceof Node)) {
            throw new Error(`Cannot dispatch mouse event: ${selector} is not a node`);
        }
        const dispatchedEvent = dispatchMouseEvent(element, type, x, y, event);
        this.detectChanges();
        return dispatchedEvent;
    }
    dispatchKeyboardEvent(selector = this.element, type, keyOrKeyCode, target) {
        const element = this.getNativeElement(selector);
        if (!(element instanceof Node)) {
            throw new Error(`Cannot dispatch keyboard event: ${selector} is not a node`);
        }
        const event = dispatchKeyboardEvent(element, type, keyOrKeyCode, target);
        this.detectChanges();
        return event;
    }
    dispatchFakeEvent(selector = this.element, type, canBubble) {
        const event = dispatchFakeEvent(this.getNativeElement(selector), type, canBubble);
        this.detectChanges();
        return event;
    }
    triggerEventHandler(directiveOrSelector, eventName, eventObj) {
        const debugElement = this.getDebugElement(directiveOrSelector);
        if (!debugElement) {
            // tslint:disable:no-console
            console.error(`${directiveOrSelector} does not exists`);
            return;
        }
        debugElement.triggerEventHandler(eventName, eventObj);
        this.detectChanges();
    }
    get keyboard() {
        return {
            pressKey: (key, selector = this.element, event = KEY_UP) => {
                this.dispatchKeyboardEvent(selector, event, key);
            },
            pressEscape: (selector = this.element, event = KEY_UP) => {
                this.dispatchKeyboardEvent(selector, event, { key: 'Escape', keyCode: 27 });
            },
            pressEnter: (selector = this.element, event = KEY_UP) => {
                this.dispatchKeyboardEvent(selector, event, { key: 'Enter', keyCode: 13 });
            },
            pressTab: (selector = this.element, event = KEY_UP) => {
                this.dispatchKeyboardEvent(selector, event, { key: 'Tab', keyCode: 9 });
            },
            pressBackspace: (selector = this.element, event = KEY_UP) => {
                this.dispatchKeyboardEvent(selector, event, { key: 'Backspace', keyCode: 8 });
            }
        };
    }
    get mouse() {
        return {
            contextmenu: (selector = this.element) => {
                this.dispatchMouseEvent(selector, 'contextmenu');
            },
            dblclick: (selector = this.element) => {
                this.dispatchMouseEvent(selector, 'dblclick');
            }
        };
    }
    dispatchTouchEvent(selector = this.element, type, x = 0, y = 0) {
        dispatchTouchEvent(this.getNativeElement(selector), type, x, y);
        this.detectChanges();
    }
    typeInElement(value, selector = this.element) {
        typeInElement(value, this.getNativeElement(selector));
        this.detectChanges();
    }
    selectOption(selector = this.element, options, config = { emitEvents: true }) {
        if (!selector) {
            throw new Error(`Cannot find select: ${selector}`);
        }
        selectOption(options, this.getNativeElement(selector), config);
        this.detectChanges();
    }
    getNativeElement(selector) {
        let element;
        // Support global objects window and document
        if (selector === window || selector === document) {
            return selector;
        }
        if (isString(selector)) {
            const exists = this.debugElement.query(By.css(selector));
            if (exists) {
                element = exists.nativeElement;
            }
            else {
                // tslint:disable:no-console
                console.error(`${selector} does not exists`);
            }
        }
        else if (selector instanceof DOMSelector) {
            element = selector.execute(document)[0] || null;
        }
        else {
            if (selector instanceof DebugElement || selector instanceof ElementRef) {
                element = selector.nativeElement;
            }
            else {
                element = selector;
            }
        }
        return element;
    }
    getDebugElement(directiveOrSelector) {
        let debugElement;
        if (isString(directiveOrSelector)) {
            debugElement = this.debugElement.query(By.css(directiveOrSelector));
        }
        else if (directiveOrSelector instanceof DebugElement) {
            debugElement = directiveOrSelector;
        }
        else {
            debugElement = this.debugElement.query(By.directive(directiveOrSelector));
        }
        return debugElement;
    }
}

/**
 * @publicApi
 */
class Spectator extends DomSpectator {
    constructor(fixture, debugElement, instance, element) {
        super(fixture, debugElement, instance, element);
        this.fixture = fixture;
        this.debugElement = debugElement;
        this.instance = instance;
        this.element = element;
    }
    get component() {
        return this.instance;
    }
    inject(token, fromComponentInjector = false) {
        if (fromComponentInjector) {
            return this.debugElement.injector.get(token);
        }
        return super.inject(token);
    }
    detectComponentChanges() {
        if (this.debugElement) {
            this.debugElement.injector.get(ChangeDetectorRef).detectChanges();
        }
        else {
            this.detectChanges();
        }
    }
}

/**
 * @license
 * Copyright Netanel Basal. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NetanelBasal/spectator/blob/master/LICENSE
 */
function hex2rgb(hex) {
    const h = hex.replace('#', '');
    const matches = h.match(new RegExp('(.{' + h.length / 3 + '})', 'g'));
    const [r, g, b] = matches.map(match => parseInt(match.length === 1 ? match + match : match, 16));
    return `rgb(${r},${g},${b})`;
}
function isHex(value) {
    return /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(value);
}
function trim(value) {
    return (value || '').replace(/\s/g, '');
}

function isRunningInJsDom() {
    return navigator.userAgent.includes('Node.js') || navigator.userAgent.includes('jsdom');
}

/** Credit: https://github.com/unindented/custom-jquery-matchers/tree/master/packages/custom-jquery-matchers */
const hasProperty = (actual, expected) => {
    return expected === undefined ? actual !== undefined : actual === expected;
};
const ɵ0$1 = hasProperty;
const containsProperty = (actual, expected) => {
    return expected === undefined ? true : actual.includes(expected);
};
const ɵ1 = containsProperty;
const checkProperty = (el, prop, predicate) => {
    let pass = false;
    let failing = '';
    for (const key of Object.keys(prop)) {
        const actual = $(el).prop(key);
        const addendum = prop[key] !== undefined ? ` with value '${prop[key]}'` : '';
        pass = predicate(actual, prop[key]);
        failing = !pass ? `'${prop}'${addendum}, but had '${actual}'` : '';
    }
    const message = () => `Expected element${pass ? ' not' : ''} to have property ${failing}`;
    return { pass, message };
};
const ɵ2 = checkProperty;
const hasCss = (el, css) => {
    let prop;
    let value;
    const $el = $(el);
    for (prop in css) {
        if (css.hasOwnProperty(prop)) {
            value = css[prop];
            if (isHex(value)) {
                value = hex2rgb(css[prop]);
            }
            if (value === 'auto' && $el.get(0).style[prop] === 'auto') {
                continue;
            }
            if (trim($el.css(prop)) !== trim(value) && trim(el.style[prop]) !== trim(value)) {
                return false;
            }
        }
    }
    return true;
};
const ɵ3 = hasCss;
const hasSameText = (el, expected, exact = false) => {
    if (expected && Array.isArray(expected)) {
        let actual;
        let pass = false;
        let failing;
        $(el).each((i, e) => {
            actual = exact ? $(e).text() : $.trim($(e).text());
            pass = exact ? actual === expected[i] : actual.includes(expected[i]);
            if (!pass) {
                failing = expected[i];
                return false;
            }
        });
        const message = () => `Expected element${pass ? ' not' : ''} to have ${exact ? 'exact' : ''} text '${failing}', but had '${actual}'`;
        return { pass, message };
    }
    const actual = exact ? $(el).text() : $.trim($(el).text());
    if (expected && typeof expected !== 'string') {
        const pass = expected(actual);
        const message = () => `Expected element${pass ? ' not' : ''} to have ${exact ? 'exact' : ''} text matching '${expected}',` + ` but had '${actual}'`;
        return { pass, message };
    }
    const pass = exact && !Array.isArray(expected) ? actual === expected : actual.indexOf(expected) !== -1;
    const message = () => `Expected element${pass ? ' not' : ''} to have ${exact ? 'exact' : ''} text '${expected}', but had '${actual}'`;
    return { pass, message };
};
const ɵ4 = hasSameText;
const comparator = (func) => () => ({
    compare: func
});
const ɵ5 = comparator;
const ɵ6 = (el) => {
    const actual = $(el).length;
    const pass = actual > 0;
    const message = () => `Expected ${el} element${pass ? ' not' : ''} to exist`;
    return { pass, message };
};
/**
 *
 * expect('.zippy__content').not.toExist();
 */
const toExist = comparator(ɵ6);
const ɵ7 = (el, expected) => {
    const actual = $(el).length;
    const pass = actual === expected;
    const message = () => `Expected element${pass ? ' not' : ''} to have length ${expected}, but had ${actual}`;
    return { pass, message };
};
/**
 *
 * expect('.zippy__content').toHaveLength(3);
 */
const toHaveLength = comparator(ɵ7);
const ɵ8 = (el, expected) => {
    const actual = $(el).attr('id');
    const pass = actual === expected;
    const message = () => `Expected element${pass ? ' not' : ''} to have ID '${expected}', but had '${actual}'`;
    return { pass, message };
};
/**
 *
 * expect('.zippy__content').toHaveId('ID');
 */
const toHaveId = comparator(ɵ8);
const ɵ9 = (el, expected) => {
    if (expected && Array.isArray(expected)) {
        const actual = $(el).attr('class');
        const expectedClasses = expected.join(' ');
        const pass = $(el).hasClass(expectedClasses);
        const message = () => `Expected element${pass ? ' not' : ''} to have value '${expectedClasses}', but had '${actual}'`;
        return { pass, message };
    }
    const actual = $(el).attr('class');
    const pass = $(el).hasClass(expected);
    const message = () => `Expected element${pass ? ' not' : ''} to have class '${expected}', but had '${actual}'`;
    return { pass, message };
};
/**
 *
 * expect('.zippy__content').toHaveClass('class');
 * expect('.zippy__content').toHaveClass('class a, class b');
 * expect('.zippy__content').toHaveClass(['class a, class b']);
 */
const toHaveClass = comparator(ɵ9);
const ɵ10 = (el, attr, val) => {
    if (isObject(attr)) {
        let pass = false;
        let failing;
        for (const key of Object.keys(attr)) {
            const actual = $(el).attr(key);
            const addendum = attr[key] !== undefined ? ` with value '${attr[key]}'` : '';
            pass = hasProperty(actual, attr[key]);
            failing = !pass ? `'${attr}'${addendum}, but had '${actual}'` : '';
        }
        const message = () => `Expected element${pass ? ' not' : ''} to have attribute ${failing}`;
        return { pass, message };
    }
    const actual = $(el).attr(attr);
    const addendum = val !== undefined ? ` with value '${val}'` : '';
    const pass = hasProperty(actual, val);
    const message = () => `Expected element${pass ? ' not' : ''} to have attribute '${attr}'${addendum}, but had '${actual}'`;
    return { pass, message };
};
/**
 * expect(host.query('.zippy')).toHaveAttribute('id', 'zippy');
 */
const toHaveAttribute = comparator(ɵ10);
const ɵ11 = (el, prop, val) => {
    if (isObject(prop)) {
        return checkProperty(el, prop, hasProperty);
    }
    const actual = $(el).prop(prop);
    const addendum = val !== undefined ? ` with value '${val}'` : '';
    const pass = hasProperty(actual, val);
    const message = () => `Expected element${pass ? ' not' : ''} to have property '${prop}'${addendum}, but had '${actual}'`;
    return { pass, message };
};
/**
 *  expect(host.query('.checkbox')).toHaveProperty('checked', true);
 *  expect(host.query('.checkbox')).toHaveProperty({checked: true});
 */
const toHaveProperty = comparator(ɵ11);
const ɵ12 = (el, prop, val) => {
    if (isObject(prop)) {
        return checkProperty(el, prop, containsProperty);
    }
    const actual = $(el).prop(prop);
    const addendum = val !== undefined ? ` with value '${val}'` : '';
    const pass = containsProperty(actual, val);
    const message = () => `Expected element${pass ? ' not' : ''} to have property '${prop}'${addendum}, but had '${actual}'`;
    return { pass, message };
};
const toContainProperty = comparator(ɵ12);
const ɵ13 = (el, expected, exact = false) => hasSameText(el, expected, exact);
/**
 *
 * expect('.zippy__content').toHaveText('Content');
 * expect('.zippy__content').toHaveText(['Content A', 'Content B']);
 *
 * expect('.zippy__content').toHaveText((text) => text.includes('..');
 */
const toHaveText = comparator(ɵ13);
const ɵ14 = (el, expected) => hasSameText(el, expected, true);
const toHaveExactText = comparator(ɵ14);
const toContainText = toHaveText;
const ɵ15 = (el, expected) => {
    if (expected && Array.isArray(expected)) {
        let actual;
        let pass = false;
        let failing;
        $(el).each((i, e) => {
            actual = $(e).val();
            pass = actual === expected[i];
            if (!pass) {
                failing = expected[i];
                return false;
            }
        });
        const message = () => `Expected element${pass ? ' not' : ''} to have value '${failing}', but had '${actual}'`;
        return { pass, message };
    }
    const actual = $(el).val();
    const pass = actual === expected;
    const message = () => `Expected element${pass ? ' not' : ''} to have value '${expected}', but had '${actual}'`;
    return { pass, message };
};
/**
 *
 * expect('.zippy__content').toHaveValue('value');
 * expect('.zippy__content').toHaveValue(['value a', 'value b']);
 */
const toHaveValue = comparator(ɵ15);
const toContainValue = toHaveValue;
const ɵ16 = (el, expected) => {
    const pass = hasCss(el, expected);
    const message = () => `Expected element${pass ? ' not' : ''} to have CSS ${JSON.stringify(expected)}`;
    return { pass, message };
};
/**
 *
 *  expect(host.element).toHaveStyle({
 *    backgroundColor: 'rgba(0, 0, 0, 0.1)'
 *  });
 */
const toHaveStyle = comparator(ɵ16);
const ɵ17 = (el, { data, val }) => {
    const actual = $(el).data(data);
    const addendum = val !== undefined ? ` with value '${val}'` : '';
    const pass = hasProperty(actual, val);
    const message = () => `Expected element${pass ? ' not' : ''} to have data '${data}'${addendum}, but had '${actual}'`;
    return { pass, message };
};
/**
 *
 * expect('.zippy__content').toHaveData({data: 'role', val: 'admin'});
 */
const toHaveData = comparator(ɵ17);
const ɵ18 = el => {
    const pass = $(el).is(':checked');
    const message = () => `Expected element${pass ? ' not' : ''} to be checked`;
    return { pass, message };
};
/**
 *
 * expect('.checkbox').toBeChecked();
 */
const toBeChecked = comparator(ɵ18);
const ɵ19 = el => {
    const pass = $(el).is(':disabled');
    const message = () => `Expected element${pass ? ' not' : ''} to be disabled`;
    return { pass, message };
};
/**
 *
 * expect('.checkbox').toBeDisabled();
 */
const toBeDisabled = comparator(ɵ19);
const ɵ20 = el => {
    const pass = $(el).is(':empty');
    const message = () => `Expected element${pass ? ' not' : ''} to be empty`;
    return { pass, message };
};
/**
 * An empty element is an element without child elements or text.
 *
 * expect('div').toBeEmpty();
 */
const toBeEmpty = comparator(ɵ20);
/**
 * Hidden elements are elements that have:
 * 1. Display property set to "none"
 * 2. Width and height set to 0 (check not applied in jest)
 * 3. A hidden parent element (this also hides child elements)
 * 4. Type equal to "hidden" (only for form elements)
 * 5. A "hidden" attribute
 */
function isHidden(elOrSelector) {
    let el = $(elOrSelector)[0];
    if (!el) {
        return true;
    }
    const hiddenWhen = [
        el => !(el.offsetWidth || el.offsetHeight || el.getClientRects().length),
        el => el.style.display === 'none',
        el => el.style.visibility === 'hidden',
        el => el.type === 'hidden',
        el => el.hasAttribute('hidden')
    ];
    if (isRunningInJsDom()) {
        // When running in JSDOM (Jest), offset-properties and client rects are always reported as 0
        // - hence, let's take a more "naive" approach here. (https://github.com/jsdom/jsdom/issues/135)
        hiddenWhen.shift();
    }
    while (el) {
        if (el === document) {
            break;
        }
        if (hiddenWhen.some(rule => rule(el))) {
            return true;
        }
        el = el.parentNode;
    }
    return false;
}
const ɵ21 = el => {
    const pass = isHidden(el);
    const message = () => `Expected element${pass ? ' not' : ''} to be hidden`;
    return { pass, message };
};
/**
 * Hidden elements are elements that have:
 * 1. Display property set to "none"
 * 2. Width and height set to 0
 * 3. A hidden parent element (this also hides child elements)
 * 4. Type equal to "hidden" (only for form elements)
 * 5. A "hidden" attribute
 *
 * expect('div').toBeHidden();
 *
 */
const toBeHidden = comparator(ɵ21);
const ɵ22 = el => {
    const pass = $(el).is(':selected');
    const message = () => `Expected element${pass ? ' not' : ''} to be selected`;
    return { pass, message };
};
/**
 * The :selected selector selects option elements that are pre-selected.
 *
 * expect('div').toBeSelected();
 *
 */
const toBeSelected = comparator(ɵ22);
const ɵ23 = el => {
    const pass = !isHidden(el);
    const message = () => `Expected element${pass ? ' not' : ''} to be visible`;
    return { pass, message };
};
/**
 * Hidden elements are elements that have:
 * 1. Display property set to "none"
 * 2. Width and height set to 0
 * 3. A hidden parent element (this also hides child elements)
 * 4. Type equal to "hidden" (only for form elements)
 * 5. A "hidden" attribute
 *
 * expect('div').toBeVisible();
 *
 */
const toBeVisible = comparator(ɵ23);
const ɵ24 = el => {
    const element = $(el).get(0);
    const pass = element === element.ownerDocument.activeElement;
    const message = () => `Expected element${pass ? ' not' : ''} to be focused`;
    return { pass, message };
};
/**
 * The :focus selector selects the element that currently has focus.
 *
 * expect('input').toBeFocused();
 */
const toBeFocused = comparator(ɵ24);
const ɵ25 = (el, expected) => {
    const actual = $(el).filter(expected).length;
    const pass = actual > 0;
    const message = () => `Expected element${pass ? ' not' : ''} to be matched by '${expected}'`;
    return { pass, message };
};
/**
 * Check to see if the set of matched elements matches the given selector
 * returns true if the dom contains the element
 *
 * expect('div').toBeMatchedBy('.js-something')
 */
const toBeMatchedBy = comparator(ɵ25);
const ɵ26 = (el, selector) => {
    const actual = $(el).find(selector).length;
    const pass = actual > 0;
    const message = () => `Expected element${pass ? ' not' : ''} to contain child '${selector}'`;
    return { pass, message };
};
/**
 *
 * expect('div').toHaveDescendant('.child')
 */
const toHaveDescendant = comparator(ɵ26);
const ɵ27 = (el, { selector, text }) => {
    const actual = $.trim($(el)
        .find(selector)
        .text());
    if (text && $.isFunction(text.test)) {
        const pass = text.test(actual);
        const message = () => `Expected element${pass ? ' not' : ''} to have descendant '${selector}' with text matching '${text}',` + ` but had '${actual}'`;
        return { pass, message };
    }
    const pass = actual.indexOf(text) !== -1;
    const message = () => `Expected element${pass ? ' not' : ''} to have descendant '${selector}' with text '${text}', but had '${actual}'`;
    return { pass, message };
};
/**
 *
 * expect('div').toHaveDescendantWithText({selector: '.child', text: 'text'})
 */
const toHaveDescendantWithText = comparator(ɵ27);
const ɵ28 = (el, expected) => {
    if (expected instanceof HTMLOptionElement) {
        const actual = $(el).find(':selected');
        const pass = actual.is($(expected));
        const message = () => `Expected element${pass ? ' not' : ''} to have options '[${expected.outerHTML}]' but had '[${actual[0].outerHTML}]'`;
        return { pass, message };
    }
    if (isHTMLOptionElementArray(expected)) {
        const actual = $(el).find(':selected');
        const pass = actual.length === expected.length && actual.toArray().every((_, index) => $(actual[index]).is(expected[index]));
        const expectedOptionsString = $(expected)
            .get()
            .map(option => option.outerHTML)
            .join(',');
        const actualOptionsString = actual
            .get()
            .map(option => option.outerHTML)
            .join(',');
        const message = () => `Expected element${pass ? ' not' : ''} to have options '[${expectedOptionsString}]' but had '[${actualOptionsString}]'`;
        return { pass, message };
    }
    const actual = $(el).val();
    const pass = JSON.stringify([...actual]) === JSON.stringify([...expected]);
    const expectedOptionsString = Array.isArray(expected)
        ? expected.reduce((acc, val, i) => acc + `${i === expected.length ? '' : ','}${val}`)
        : expected;
    const message = () => `Expected element${pass ? ' not' : ''} to have options '[${expectedOptionsString}]' but had '[${actual}]'`;
    return { pass, message };
};
const toHaveSelectedOptions = comparator(ɵ28);

var customMatchers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    toExist: toExist,
    toHaveLength: toHaveLength,
    toHaveId: toHaveId,
    toHaveClass: toHaveClass,
    toHaveAttribute: toHaveAttribute,
    toHaveProperty: toHaveProperty,
    toContainProperty: toContainProperty,
    toHaveText: toHaveText,
    toHaveExactText: toHaveExactText,
    toContainText: toContainText,
    toHaveValue: toHaveValue,
    toContainValue: toContainValue,
    toHaveStyle: toHaveStyle,
    toHaveData: toHaveData,
    toBeChecked: toBeChecked,
    toBeDisabled: toBeDisabled,
    toBeEmpty: toBeEmpty,
    toBeHidden: toBeHidden,
    toBeSelected: toBeSelected,
    toBeVisible: toBeVisible,
    toBeFocused: toBeFocused,
    toBeMatchedBy: toBeMatchedBy,
    toHaveDescendant: toHaveDescendant,
    toHaveDescendantWithText: toHaveDescendantWithText,
    toHaveSelectedOptions: toHaveSelectedOptions,
    ɵ0: ɵ0$1,
    ɵ1: ɵ1,
    ɵ2: ɵ2,
    ɵ3: ɵ3,
    ɵ4: ɵ4,
    ɵ5: ɵ5,
    ɵ6: ɵ6,
    ɵ7: ɵ7,
    ɵ8: ɵ8,
    ɵ9: ɵ9,
    ɵ10: ɵ10,
    ɵ11: ɵ11,
    ɵ12: ɵ12,
    ɵ13: ɵ13,
    ɵ14: ɵ14,
    ɵ15: ɵ15,
    ɵ16: ɵ16,
    ɵ17: ɵ17,
    ɵ18: ɵ18,
    ɵ19: ɵ19,
    ɵ20: ɵ20,
    ɵ21: ɵ21,
    ɵ22: ɵ22,
    ɵ23: ɵ23,
    ɵ24: ɵ24,
    ɵ25: ɵ25,
    ɵ26: ɵ26,
    ɵ27: ɵ27,
    ɵ28: ɵ28
});

function addMatchers(matchers) {
    if (!matchers)
        return;
    if (typeof jasmine !== 'undefined') {
        jasmine.addMatchers(matchers);
    }
    if (typeof jest !== 'undefined') {
        const jestExpectExtend = {};
        for (const key of Object.keys(matchers)) {
            if (key.startsWith('to'))
                jestExpectExtend[key] = matchers[key]().compare;
        }
        expect.extend(jestExpectExtend);
    }
}

let globals = {
    providers: [],
    declarations: [],
    imports: []
};
function defineGlobalsInjections(config) {
    globals = Object.assign(Object.assign({}, globals), config);
}
function getGlobalsInjections() {
    return globals;
}

/**
 * @internal
 */
function initialModule(options) {
    const globals = Object.assign({ imports: [], declarations: [], providers: [] }, getGlobalsInjections());
    return {
        declarations: [...globals.declarations, ...options.declarations, ...options.entryComponents],
        imports: [...(options.disableAnimations ? [NoopAnimationsModule] : []), ...globals.imports, ...options.imports],
        providers: [...globals.providers, ...options.providers, ...options.mocks.map(type => options.mockProvider(type))],
        entryComponents: [...options.entryComponents]
    };
}

/**
 * @internal
 */
function initialSpectatorModule(options) {
    const moduleMetadata = initialModule(options);
    if (options.declareComponent) {
        moduleMetadata.declarations.push(options.component);
    }
    moduleMetadata.schemas = [options.shallow ? NO_ERRORS_SCHEMA : options.schemas || []];
    return moduleMetadata;
}

/**
 * @internal
 */
function merge(defaults, overrides) {
    // tslint:disable-next-line:no-object-literal-type-assertion
    return Object.assign(Object.assign({}, defaults), overrides);
}

/**
 * @internal
 */
function installProtoMethods(mock, proto, createSpyFn) {
    if (proto === null || proto === Object.prototype) {
        return;
    }
    for (const key of Object.getOwnPropertyNames(proto)) {
        const descriptor = Object.getOwnPropertyDescriptor(proto, key);
        if (!descriptor) {
            continue;
        }
        if (typeof descriptor.value === 'function' && key !== 'constructor' && typeof mock[key] === 'undefined') {
            mock[key] = createSpyFn(key);
        }
        else if (descriptor.get && !mock.hasOwnProperty(key)) {
            Object.defineProperty(mock, key, {
                set: value => (mock[`_${key}`] = value),
                get: () => mock[`_${key}`],
                configurable: true
            });
        }
    }
    installProtoMethods(mock, Object.getPrototypeOf(proto), createSpyFn);
    mock.castToWritable = () => mock;
}
/**
 * @publicApi
 */
function createSpyObject(type, template) {
    const mock = Object.assign({}, template) || {};
    installProtoMethods(mock, type.prototype, name => {
        const newSpy = jasmine.createSpy(name);
        newSpy.andCallFake = (fn) => newSpy.and.callFake(fn);
        newSpy.andReturn = val => newSpy.and.returnValue(val);
        newSpy.reset = () => newSpy.calls.reset();
        // revisit return null here (previously needed for rtts_assert).
        newSpy.and.returnValue(null);
        return newSpy;
    });
    return mock;
}
/**
 * @publicApi
 */
function mockProvider(type, properties) {
    return {
        provide: type,
        useFactory: () => createSpyObject(type, properties)
    };
}

const defaultOptions = {
    disableAnimations: true,
    entryComponents: [],
    mocks: [],
    mockProvider,
    providers: [],
    declarations: [],
    imports: [],
    schemas: [],
    overrideModules: []
};
/**
 * @internal
 */
function getDefaultBaseOptions(options) {
    return merge(defaultOptions, options);
}

const defaultSpectatorOptions = Object.assign(Object.assign({}, getDefaultBaseOptions()), { shallow: false, declareComponent: true, detectChanges: true, componentProviders: [], componentViewProviders: [], componentMocks: [], componentViewProvidersMocks: [] });
/**
 * @internal
 */
function getSpectatorDefaultOptions(overrides) {
    return merge(defaultSpectatorOptions, overrides);
}

/**
 * @internal
 */
function overrideComponentIfProviderOverridesSpecified(options) {
    const hasProviderOverrides = options.componentProviders.length || options.componentMocks.length;
    const hasViewProviders = options.componentViewProviders.length || options.componentViewProvidersMocks.length;
    if (hasProviderOverrides || hasViewProviders) {
        let providerConfiguration = {};
        if (hasProviderOverrides) {
            providerConfiguration = {
                providers: [...options.componentProviders, ...options.componentMocks.map(p => options.mockProvider(p))]
            };
        }
        if (hasViewProviders) {
            providerConfiguration = Object.assign(Object.assign({}, providerConfiguration), { viewProviders: [...options.componentViewProviders, ...options.componentViewProvidersMocks.map(p => options.mockProvider(p))] });
        }
        TestBed.overrideComponent(options.component, {
            set: providerConfiguration
        });
    }
}
/**
 * @internal
 */
function overrideModules(options) {
    if (options.overrideModules.length) {
        options.overrideModules.forEach(overrideModule => {
            const [ngModule, override] = overrideModule;
            TestBed.overrideModule(ngModule, override);
        });
    }
}
/**
 * @publicApi
 */
function createComponentFactory(typeOrOptions) {
    const options = isType(typeOrOptions)
        ? getSpectatorDefaultOptions({ component: typeOrOptions })
        : getSpectatorDefaultOptions(typeOrOptions);
    const moduleMetadata = initialSpectatorModule(options);
    beforeEach(async(() => {
        addMatchers(customMatchers);
        TestBed.configureTestingModule(moduleMetadata).overrideModule(BrowserDynamicTestingModule, {
            set: {
                entryComponents: moduleMetadata.entryComponents
            }
        });
        overrideModules(options);
        overrideComponentIfProviderOverridesSpecified(options);
        TestBed.compileComponents();
    }));
    return (overrides) => {
        const defaults = { props: {}, detectChanges: true, providers: [] };
        const { detectChanges, props, providers } = Object.assign(Object.assign({}, defaults), overrides);
        if (providers && providers.length) {
            providers.forEach((provider) => {
                TestBed.overrideProvider(provider.provide, provider);
            });
        }
        const spectator = createSpectator(options, props);
        if (options.detectChanges && detectChanges) {
            spectator.detectChanges();
        }
        return spectator;
    };
}
function createSpectator(options, props) {
    const fixture = TestBed.createComponent(options.component);
    const debugElement = fixture.debugElement;
    const component = setProps(fixture.componentInstance, props);
    return new Spectator(fixture, debugElement, component, debugElement.nativeElement);
}

/**
 * @publicApi
 */
class SpectatorHost extends Spectator {
    constructor(hostComponent, hostDebugElement, hostElement, hostFixture, debugElement, componentInstance, element) {
        super(hostFixture, debugElement, componentInstance, element);
        this.hostComponent = hostComponent;
        this.hostDebugElement = hostDebugElement;
        this.hostElement = hostElement;
        this.hostFixture = hostFixture;
        this.debugElement = debugElement;
        this.element = element;
    }
    queryHost(directiveOrSelector, options) {
        if ((options || {}).root && isString(directiveOrSelector)) {
            return document.querySelector(directiveOrSelector);
        }
        return getChildren(this.hostDebugElement)(directiveOrSelector, options)[0] || null;
    }
    queryHostAll(directiveOrSelector, options) {
        if ((options || {}).root && isString(directiveOrSelector)) {
            return Array.from(document.querySelectorAll(directiveOrSelector));
        }
        return getChildren(this.hostDebugElement)(directiveOrSelector, options);
    }
    setHostInput(input, value) {
        setProps(this.hostComponent, input, value, false);
        this.detectChanges();
    }
}

// TODO (dirkluijk): remove after upgrading to Angular 8.2
// see: https://github.com/angular/angular/commit/10a1e1974b816ebb979dc10586b160ee07ad8356
function nodeByDirective(type) {
    return debugNode => debugNode.providerTokens.includes(type);
}

/**
 * @internal
 */
function initialSpectatorWithHostModule(options) {
    const moduleMetadata = initialSpectatorModule(options);
    moduleMetadata.declarations.push(options.host);
    return moduleMetadata;
}

class HostComponent {
}
HostComponent.ɵfac = function HostComponent_Factory(t) { return new (t || HostComponent)(); };
HostComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: HostComponent, selectors: [["ng-component"]], decls: 0, vars: 0, template: function HostComponent_Template(rf, ctx) { }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(HostComponent, [{
        type: Component,
        args: [{
                template: ''
            }]
    }], null, null); })();
/*
  This is an unused module to resolve the ng build error:
    'Cannot determine the module for class HostComponent'

  Reference: https://github.com/angular/issues/13590
*/
class HostModule {
}
HostModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: HostModule });
HostModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function HostModule_Factory(t) { return new (t || HostModule)(); } });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(HostModule, { declarations: [HostComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(HostModule, [{
        type: NgModule,
        args: [{
                declarations: [HostComponent]
            }]
    }], null, null); })();

const defaultSpectatorHostOptions = Object.assign(Object.assign({}, getSpectatorDefaultOptions()), { host: HostComponent, template: '' });
/**
 * @internal
 */
function getSpectatorHostDefaultOptions(overrides) {
    return merge(defaultSpectatorHostOptions, overrides);
}

function createHostFactory(typeOrOptions) {
    const options = isType(typeOrOptions)
        ? getSpectatorHostDefaultOptions({ component: typeOrOptions })
        : getSpectatorHostDefaultOptions(typeOrOptions);
    const moduleMetadata = initialSpectatorWithHostModule(options);
    beforeEach(async(() => {
        addMatchers(customMatchers);
        TestBed.configureTestingModule(moduleMetadata);
        overrideModules(options);
        overrideComponentIfProviderOverridesSpecified(options);
    }));
    return (template, overrides) => {
        const defaults = { props: {}, hostProps: {}, detectChanges: true, providers: [] };
        const { detectChanges, props, hostProps, providers } = Object.assign(Object.assign({}, defaults), overrides);
        if (providers && providers.length) {
            providers.forEach((provider) => {
                TestBed.overrideProvider(provider.provide, provider);
            });
        }
        TestBed.overrideModule(BrowserDynamicTestingModule, {
            set: {
                entryComponents: moduleMetadata.entryComponents
            }
        }).overrideComponent(options.host, {
            set: { template: template || options.template }
        });
        const spectator = createSpectatorHost(options, props, hostProps);
        if (options.detectChanges && detectChanges) {
            spectator.detectChanges();
        }
        return spectator;
    };
}
function createSpectatorHost(options, props, hostProps) {
    const hostFixture = TestBed.createComponent(options.host);
    const debugElement = hostFixture.debugElement.query(By.directive(options.component)) || hostFixture.debugElement;
    const debugNode = hostFixture.debugElement.queryAllNodes(nodeByDirective(options.component))[0];
    if (!debugNode) {
        throw new Error(`Cannot find component/directive ${options.component} in host template 😔`);
    }
    const hostComponent = setProps(hostFixture.componentInstance, hostProps);
    const component = setProps(debugNode.injector.get(options.component), props);
    return new SpectatorHost(hostComponent, hostFixture.debugElement, hostFixture.nativeElement, hostFixture, debugElement, component, debugElement.nativeElement);
}

/**
 * @publicApi
 */
class SpectatorDirective extends DomSpectator {
    constructor(hostComponent, fixture, debugElement, instance, element) {
        super(fixture, debugElement, instance, element);
        this.hostComponent = hostComponent;
        this.fixture = fixture;
        this.debugElement = debugElement;
        this.instance = instance;
        this.element = element;
    }
    get directive() {
        return this.instance;
    }
    inject(token, fromDirectiveInjector = false) {
        if (fromDirectiveInjector) {
            return this.debugElement.injector.get(token);
        }
        return super.inject(token);
    }
    setHostInput(input, value) {
        setProps(this.hostComponent, input, value, false);
        this.detectChanges();
    }
}

/**
 * @internal
 */
function initialSpectatorDirectiveModule(options) {
    const moduleMetadata = initialModule(options);
    if (options.declareDirective) {
        moduleMetadata.declarations.push(options.directive);
    }
    moduleMetadata.declarations.push(options.host);
    moduleMetadata.schemas = [options.shallow ? NO_ERRORS_SCHEMA : options.schemas || []];
    return moduleMetadata;
}

const defaultSpectatorRoutingOptions = Object.assign(Object.assign({}, getDefaultBaseOptions()), { host: HostComponent, template: '', shallow: false, detectChanges: true, directiveProviders: [], directiveMocks: [], declareDirective: true });
/**
 * @internal
 */
function getSpectatorDirectiveDefaultOptions(overrides) {
    return merge(defaultSpectatorRoutingOptions, overrides);
}

function createDirectiveFactory(typeOrOptions) {
    const options = isType(typeOrOptions)
        ? getSpectatorDirectiveDefaultOptions({ directive: typeOrOptions })
        : getSpectatorDirectiveDefaultOptions(typeOrOptions);
    const moduleMetadata = initialSpectatorDirectiveModule(options);
    beforeEach(async(() => {
        addMatchers(customMatchers);
        TestBed.configureTestingModule(moduleMetadata);
        overrideModules(options);
    }));
    return (template, overrides) => {
        const defaults = {
            props: {},
            hostProps: {},
            detectChanges: true,
            providers: []
        };
        const { detectChanges, props, hostProps, providers } = Object.assign(Object.assign({}, defaults), overrides);
        if (providers && providers.length) {
            providers.forEach((provider) => {
                TestBed.overrideProvider(provider.provide, provider);
            });
        }
        TestBed.overrideModule(BrowserDynamicTestingModule, {
            set: {
                entryComponents: moduleMetadata.entryComponents
            }
        }).overrideComponent(options.host, {
            set: { template: template || options.template }
        });
        if (options.directiveProviders.length || options.directiveMocks.length) {
            TestBed.overrideDirective(options.directive, {
                set: { providers: [...options.directiveProviders, ...options.directiveMocks.map(p => options.mockProvider(p))] }
            });
        }
        const spectator = createSpectatorDirective(options, props, hostProps);
        if (options.detectChanges && detectChanges) {
            spectator.detectChanges();
        }
        return spectator;
    };
}
function createSpectatorDirective(options, props, hostProps) {
    const hostFixture = TestBed.createComponent(options.host);
    const debugElement = hostFixture.debugElement.query(By.directive(options.directive)) || hostFixture.debugElement;
    const debugNode = hostFixture.debugElement.queryAllNodes(nodeByDirective(options.directive))[0];
    if (!debugNode) {
        throw new Error(`Cannot find directive ${options.directive} in host template 😔`);
    }
    const hostComponent = setProps(hostFixture.componentInstance, hostProps);
    const directive = setProps(debugNode.injector.get(options.directive), props);
    return new SpectatorDirective(hostComponent, hostFixture, hostFixture.debugElement, directive, debugElement.nativeElement);
}

/**
 * @publicApi
 */
class SpectatorService extends BaseSpectator {
    constructor(service) {
        super();
        this.service = service;
    }
}

/**
 * @internal
 */
function initialServiceModule(options) {
    const moduleMetadata = initialModule(options);
    moduleMetadata.providers.push(options.service);
    return moduleMetadata;
}

const defaultServiceOptions = Object.assign({}, getDefaultBaseOptions());
/**
 * @internal
 */
function getDefaultServiceOptions(overrides) {
    return merge(defaultServiceOptions, overrides);
}

/**
 * @publicApi
 */
function createServiceFactory(typeOrOptions) {
    const service = isType(typeOrOptions) ? typeOrOptions : typeOrOptions.service;
    const options = isType(typeOrOptions) ? getDefaultServiceOptions({ service }) : getDefaultServiceOptions(typeOrOptions);
    const moduleMetadata = initialServiceModule(options);
    beforeEach(() => {
        TestBed.configureTestingModule(moduleMetadata);
        overrideModules(options);
    });
    afterEach(() => {
        const testedService = TestBed.inject
            ? TestBed.inject(service)
            : TestBed.get(service);
        if (doesServiceImplementsOnDestroy(testedService)) {
            // tslint:disable-next-line:no-life-cycle-call
            testedService.ngOnDestroy();
        }
    });
    return (overrides) => {
        const defaults = { providers: [] };
        const { providers } = Object.assign(Object.assign({}, defaults), overrides);
        if (providers && providers.length) {
            providers.forEach((provider) => {
                TestBed.overrideProvider(provider.provide, provider);
            });
        }
        return new SpectatorService(TestBed.inject ? TestBed.inject(service) : TestBed.get(service));
    };
}

class RouterStub extends Router {
}
function isRouterStub(router) {
    return 'emitRouterEvent' in router;
}

/**
 * @publicApi
 */
class SpectatorRouting extends Spectator {
    constructor(fixture, debugElement, instance, router, activatedRouteStub) {
        super(fixture, debugElement, instance, debugElement.nativeElement);
        this.router = router;
        this.activatedRouteStub = activatedRouteStub;
    }
    /**
     * Simulates a route navigation by updating the Params, QueryParams and Data observable streams.
     */
    triggerNavigation(options) {
        if (!this.checkStubPresent()) {
            return;
        }
        if (options && options.params) {
            this.activatedRouteStub.setParams(options.params);
        }
        if (options && options.queryParams) {
            this.activatedRouteStub.setQueryParams(options.queryParams);
        }
        if (options && options.data) {
            this.activatedRouteStub.setAllData(options.data);
        }
        if (options && options.fragment) {
            this.activatedRouteStub.setFragment(options.fragment);
        }
        this.triggerNavigationAndUpdate();
    }
    /**
     * Updates the route params and triggers a route navigation.
     */
    setRouteParam(name, value) {
        if (this.checkStubPresent()) {
            this.activatedRouteStub.setParam(name, value);
            this.triggerNavigationAndUpdate();
        }
    }
    /**
     * Updates the route query params and triggers a route navigation.
     */
    setRouteQueryParam(name, value) {
        if (this.checkStubPresent()) {
            this.activatedRouteStub.setQueryParam(name, value);
            this.triggerNavigationAndUpdate();
        }
    }
    /**
     * Updates the route data and triggers a route navigation.
     */
    setRouteData(name, value) {
        if (this.checkStubPresent()) {
            this.activatedRouteStub.setData(name, value);
            this.triggerNavigationAndUpdate();
        }
    }
    /**
     * Updates the route fragment and triggers a route navigation.
     */
    setRouteFragment(fragment) {
        if (this.checkStubPresent()) {
            this.activatedRouteStub.setFragment(fragment);
            this.triggerNavigationAndUpdate();
        }
    }
    /**
     * Updates the route url and triggers a route navigation.
     */
    setRouteUrl(url) {
        if (this.checkStubPresent()) {
            this.activatedRouteStub.setUrl(url);
            this.triggerNavigationAndUpdate();
        }
    }
    /**
     * Emits a router event
     */
    emitRouterEvent(event) {
        if (!isRouterStub(this.router)) {
            // tslint:disable-next-line:no-console
            console.warn('No stub for Router present. Set Spectator option "stubsEnabled" to true if you want to use this ' +
                'helper, or use Router navigation to trigger events.');
            return;
        }
        this.router.emitRouterEvent(event);
    }
    triggerNavigationAndUpdate() {
        this.activatedRouteStub.triggerNavigation();
        this.detectChanges();
    }
    checkStubPresent() {
        if (!this.activatedRouteStub) {
            // tslint:disable-next-line:no-console
            console.warn('No stub for ActivatedRoute present. Set Spectator option "stubsEnabled" to true if you want to use this ' +
                'helper, or use Router to trigger navigation.');
            return false;
        }
        return true;
    }
}

/**
 * @publicApi
 *
 * Utility class for stubbing ActivatedRoute of @angular/router
 */
class ActivatedRouteStub extends ActivatedRoute {
    constructor(options) {
        super();
        this.testParams = {};
        this.testQueryParams = {};
        this.testData = {};
        this.testFragment = null;
        this.testUrl = [];
        this.testRoot = null;
        this.testParent = null;
        this.testFirstChild = null;
        this.testChildren = null;
        this.paramsSubject = new ReplaySubject(1);
        this.queryParamsSubject = new ReplaySubject(1);
        this.dataSubject = new ReplaySubject(1);
        this.fragmentSubject = new ReplaySubject(1);
        this.urlSubject = new ReplaySubject(1);
        if (options) {
            this.testParams = options.params || {};
            this.testQueryParams = options.queryParams || {};
            this.testData = options.data || {};
            this.testFragment = options.fragment || null;
            this.testUrl = options.url || [];
            this.testRoot = options.root || null;
            this.testParent = options.parent || null;
            this.testFirstChild = options.firstChild || null;
            this.testChildren = options.children || null;
        }
        this.params = this.paramsSubject.asObservable();
        this.queryParams = this.queryParamsSubject.asObservable();
        this.data = this.dataSubject.asObservable();
        this.fragment = this.fragmentSubject.asObservable();
        this.url = this.urlSubject.asObservable();
        this.snapshot = this.buildSnapshot();
        this.triggerNavigation();
    }
    get paramMap() {
        return this.paramsSubject.asObservable().pipe(map(params => convertToParamMap(params)));
    }
    setParams(params) {
        this.testParams = params;
        this.snapshot = this.buildSnapshot();
    }
    setParam(name, value) {
        this.testParams = Object.assign(Object.assign({}, this.testParams), { [name]: value });
        this.snapshot = this.buildSnapshot();
    }
    setQueryParams(queryParams) {
        this.testQueryParams = queryParams;
        this.snapshot = this.buildSnapshot();
    }
    setQueryParam(name, value) {
        this.testQueryParams = Object.assign(Object.assign({}, this.testQueryParams), { [name]: value });
        this.snapshot = this.buildSnapshot();
    }
    setAllData(data) {
        this.testData = data;
        this.snapshot = this.buildSnapshot();
    }
    setData(name, value) {
        this.testData = Object.assign(Object.assign({}, this.testData), { [name]: value });
        this.snapshot = this.buildSnapshot();
    }
    setFragment(fragment) {
        this.testFragment = fragment;
        this.snapshot = this.buildSnapshot();
    }
    setUrl(url) {
        this.testUrl = url;
        this.snapshot = this.buildSnapshot();
    }
    get root() {
        return this.testRoot || this;
    }
    get parent() {
        return this.testParent || null;
    }
    get children() {
        return this.testChildren || [this];
    }
    get firstChild() {
        return this.testFirstChild || null;
    }
    /**
     * Simulates a route navigation by updating the Params, QueryParams and Data observable streams.
     */
    triggerNavigation() {
        this.paramsSubject.next(this.testParams);
        this.queryParamsSubject.next(this.testQueryParams);
        this.dataSubject.next(this.testData);
        this.fragmentSubject.next(this.testFragment);
        this.urlSubject.next(this.testUrl);
    }
    toString() {
        return 'activatedRouteStub';
    }
    buildSnapshot() {
        const snapshot = new ActivatedRouteSnapshot();
        snapshot.params = this.testParams;
        snapshot.queryParams = this.testQueryParams;
        snapshot.data = this.testData;
        snapshot.fragment = this.testFragment;
        snapshot.url = this.testUrl;
        return snapshot;
    }
}

// tslint:disable
class RouterLinkDirectiveStub {
    constructor() {
        this.navigatedTo = null;
    }
    onClick() {
        this.navigatedTo = this.routerLink;
        return true;
    }
}
RouterLinkDirectiveStub.ɵfac = function RouterLinkDirectiveStub_Factory(t) { return new (t || RouterLinkDirectiveStub)(); };
RouterLinkDirectiveStub.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: RouterLinkDirectiveStub, selectors: [["", "routerLink", ""]], hostBindings: function RouterLinkDirectiveStub_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function RouterLinkDirectiveStub_click_HostBindingHandler() { return ctx.onClick(); });
    } }, inputs: { routerLink: "routerLink" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: RouterLink,
                useExisting: RouterLinkDirectiveStub
            }
        ])] });
RouterLinkDirectiveStub.propDecorators = {
    routerLink: [{ type: Input }],
    onClick: [{ type: HostListener, args: ['click',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(RouterLinkDirectiveStub, [{
        type: Directive,
        args: [{
                selector: '[routerLink]',
                providers: [
                    {
                        provide: RouterLink,
                        useExisting: RouterLinkDirectiveStub
                    }
                ]
            }]
    }], function () { return []; }, { onClick: [{
            type: HostListener,
            args: ['click']
        }], routerLink: [{
            type: Input
        }] }); })();
/*
  This is an unused module to resolve the ng build error:
    'Cannot determine the module for class RouterLinkDirectiveStub'

  Reference: https://github.com/angular/issues/13590
*/
class RouterLinkDirectiveStubModule {
}
RouterLinkDirectiveStubModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: RouterLinkDirectiveStubModule });
RouterLinkDirectiveStubModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function RouterLinkDirectiveStubModule_Factory(t) { return new (t || RouterLinkDirectiveStubModule)(); } });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(RouterLinkDirectiveStubModule, { declarations: [RouterLinkDirectiveStub] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(RouterLinkDirectiveStubModule, [{
        type: NgModule,
        args: [{
                declarations: [RouterLinkDirectiveStub]
            }]
    }], null, null); })();

/**
 * @internal
 */
function initialRoutingModule(options) {
    const moduleMetadata = initialSpectatorModule(options);
    if (options.mockRouterLinks && options.stubsEnabled) {
        moduleMetadata.declarations.push(RouterLinkDirectiveStub);
    }
    if (options.stubsEnabled) {
        moduleMetadata.providers.push(options.mockProvider(RouterStub, {
            events: new Subject(),
            emitRouterEvent(event) {
                this.events.next(event);
            }
        }), {
            provide: Router,
            useExisting: RouterStub
        });
        moduleMetadata.providers.push({
            provide: ActivatedRouteStub,
            useValue: new ActivatedRouteStub({
                params: options.params,
                queryParams: options.queryParams,
                data: options.data
            })
        }, {
            provide: ActivatedRoute,
            useExisting: ActivatedRouteStub
        });
    }
    else {
        moduleMetadata.imports.push(RouterTestingModule.withRoutes(options.routes));
    }
    return moduleMetadata;
}

const ɵ0$2 = {};
const defaultRoutingOptions = Object.assign(Object.assign({}, getSpectatorDefaultOptions()), { params: {}, queryParams: {}, data: ɵ0$2, fragment: null, mockRouterLinks: true, stubsEnabled: true, routes: [], url: [], root: null, parent: null, children: null, firstChild: null });
/**
 * @internal
 */
function getRoutingDefaultOptions(overrides) {
    return merge(defaultRoutingOptions, overrides);
}

/**
 * @publicApi
 */
function createRoutingFactory(typeOrOptions) {
    const options = isType(typeOrOptions)
        ? getRoutingDefaultOptions({ component: typeOrOptions })
        : getRoutingDefaultOptions(typeOrOptions);
    const moduleMetadata = initialRoutingModule(options);
    beforeEach(async(() => {
        addMatchers(customMatchers);
        TestBed.configureTestingModule(moduleMetadata);
        overrideModules(options);
        overrideComponentIfProviderOverridesSpecified(options);
        TestBed.compileComponents();
    }));
    return (overrides) => {
        const defaults = {
            props: {},
            detectChanges: true,
            providers: []
        };
        const { detectChanges, props, providers } = Object.assign(Object.assign({}, defaults), overrides);
        if (providers && providers.length) {
            providers.forEach((provider) => {
                TestBed.overrideProvider(provider.provide, provider);
            });
        }
        const { params, queryParams, data, fragment, url, root, parent, children, firstChild } = Object.assign(Object.assign({}, options), overrides);
        TestBed.overrideProvider(ActivatedRoute, {
            useValue: new ActivatedRouteStub({ params, queryParams, data, fragment, url, root, parent, children, firstChild })
        });
        const ngZone = TestBed.inject ? TestBed.inject(NgZone) : TestBed.get(NgZone);
        return ngZone.run(() => {
            const spectator = createSpectatorRouting(options, props);
            spectator.router.initialNavigation();
            if (options.detectChanges && detectChanges) {
                spectator.detectChanges();
            }
            return spectator;
        });
    };
}
function createSpectatorRouting(options, props) {
    const fixture = TestBed.createComponent(options.component);
    const debugElement = fixture.debugElement;
    const component = setProps(fixture.componentInstance, props);
    /**
     * Back compatibility, angular under 9 version doesnt have a inject function
     */
    if (!TestBed.inject) {
        return new SpectatorRouting(fixture, debugElement, component, TestBed.get(Router), TestBed.get(ActivatedRoute));
    }
    return new SpectatorRouting(fixture, debugElement, component, TestBed.inject(Router), TestBed.inject(ActivatedRoute));
}

/**
 * @publicApi
 */
var HttpMethod;
(function (HttpMethod) {
    HttpMethod["GET"] = "GET";
    HttpMethod["POST"] = "POST";
    HttpMethod["DELETE"] = "DELETE";
    HttpMethod["PUT"] = "PUT";
    HttpMethod["PATCH"] = "PATCH";
    HttpMethod["HEAD"] = "HEAD";
    HttpMethod["JSONP"] = "JSONP";
    HttpMethod["OPTIONS"] = "OPTIONS";
})(HttpMethod || (HttpMethod = {}));
/**
 * @publicApi
 */
class SpectatorHttp extends BaseSpectator {
    constructor(service, httpClient, controller) {
        super();
        this.service = service;
        this.httpClient = httpClient;
        this.controller = controller;
        // small workaround to prevent issues if destructuring SpectatorHttp, which was common in Spectator 3
        // remove in v5?
        this.expectOne = this.expectOne.bind(this);
        this.expectConcurrent = this.expectConcurrent.bind(this);
    }
    expectOne(url, method) {
        expect(true).toBe(true); // workaround to avoid `Spec has no expectations` https://github.com/NetanelBasal/spectator/issues/75
        const req = this.controller.expectOne({
            url,
            method
        });
        // assert that there are no outstanding requests.
        this.controller.verify();
        return req;
    }
    expectConcurrent(expectations) {
        const requests = expectations.map((expectation) => {
            return this.controller.expectOne({
                url: expectation.url,
                method: expectation.method
            });
        });
        this.controller.verify();
        return requests;
    }
    flushAll(requests, args) {
        requests.forEach((request, idx) => {
            request.flush(args[idx]);
        });
    }
}

/**
 * @internal
 */
function initialHttpModule(options) {
    const moduleMetadata = initialModule(options);
    moduleMetadata.providers.push(options.service);
    moduleMetadata.imports.push(HttpClientTestingModule);
    return moduleMetadata;
}

const defaultHttpOptions = Object.assign({}, getDefaultBaseOptions());
/**
 * @internal
 */
function getDefaultHttpOptions(overrides) {
    return merge(defaultHttpOptions, overrides);
}

/**
 * @publicApi
 */
function createHttpFactory(typeOrOptions) {
    const service = isType(typeOrOptions) ? typeOrOptions : typeOrOptions.service;
    const options = isType(typeOrOptions) ? getDefaultHttpOptions({ service }) : getDefaultHttpOptions(typeOrOptions);
    const moduleMetadata = initialHttpModule(options);
    beforeEach(() => {
        TestBed.configureTestingModule(moduleMetadata);
        overrideModules(options);
    });
    afterEach(() => {
        if (TestBed.inject) {
            TestBed.inject(HttpTestingController).verify();
        }
        else {
            TestBed.get(HttpTestingController).verify();
        }
    });
    return (overrides) => {
        const defaults = { providers: [] };
        const { providers } = Object.assign(Object.assign({}, defaults), overrides);
        if (providers && providers.length) {
            providers.forEach((provider) => {
                TestBed.overrideProvider(provider.provide, provider);
            });
        }
        /**
         * Back compatibility, angular under 9 version doesnt have a inject function
         */
        if (!TestBed.inject) {
            return new SpectatorHttp(TestBed.get(service), TestBed.get(HttpClient), TestBed.get(HttpTestingController));
        }
        return new SpectatorHttp(TestBed.inject(service), TestBed.inject(HttpClient), TestBed.inject(HttpTestingController));
    };
}

/**
 * @publicApi
 */
class SpectatorPipe extends BaseSpectator {
    constructor(hostComponent, fixture, debugElement, element) {
        super();
        this.hostComponent = hostComponent;
        this.fixture = fixture;
        this.debugElement = debugElement;
        this.element = element;
    }
    detectChanges() {
        this.fixture.detectChanges();
    }
    setHostInput(input, value) {
        setProps(this.hostComponent, input, value, false);
        this.detectChanges();
    }
}

/**
 * @internal
 */
function initialSpectatorPipeModule(options) {
    const moduleMetadata = initialModule(options);
    moduleMetadata.declarations.push(options.pipe);
    moduleMetadata.declarations.push(options.host);
    return moduleMetadata;
}

const defaultSpectatorPipeOptions = Object.assign(Object.assign({}, getDefaultBaseOptions()), { host: HostComponent, detectChanges: true, template: '' });
/**
 * @internal
 */
function getSpectatorPipeDefaultOptions(overrides) {
    return merge(defaultSpectatorPipeOptions, overrides);
}

/**
 * @publicApi
 */
function createPipeFactory(typeOrOptions) {
    const options = isType(typeOrOptions)
        ? getSpectatorPipeDefaultOptions({ pipe: typeOrOptions })
        : getSpectatorPipeDefaultOptions(typeOrOptions);
    const moduleMetadata = initialSpectatorPipeModule(options);
    beforeEach(async(() => {
        addMatchers(customMatchers);
        TestBed.configureTestingModule(moduleMetadata);
        overrideModules(options);
    }));
    return (templateOrOverrides, overrides) => {
        const defaults = {
            hostProps: {},
            detectChanges: true,
            providers: []
        };
        const resolvedOverrides = typeof templateOrOverrides === 'object' ? templateOrOverrides : overrides;
        const { detectChanges, hostProps, providers } = Object.assign(Object.assign({}, defaults), resolvedOverrides);
        const template = typeof templateOrOverrides === 'string' ? templateOrOverrides : options.template;
        if (providers && providers.length) {
            providers.forEach((provider) => {
                TestBed.overrideProvider(provider.provide, provider);
            });
        }
        if (template) {
            TestBed.overrideModule(BrowserDynamicTestingModule, {
                set: {
                    entryComponents: moduleMetadata.entryComponents
                }
            }).overrideComponent(options.host, {
                set: { template }
            });
        }
        const spectator = createSpectatorPipe(options, hostProps);
        if (options.detectChanges && detectChanges) {
            spectator.detectChanges();
        }
        return spectator;
    };
}
function createSpectatorPipe(options, hostProps) {
    const hostFixture = TestBed.createComponent(options.host);
    const debugElement = hostFixture.debugElement;
    const hostComponent = setProps(hostFixture.componentInstance, hostProps);
    return new SpectatorPipe(hostComponent, hostFixture, hostFixture.debugElement, debugElement.nativeElement);
}

function MockComponentDeprecated(options) {
    const metadata = {
        selector: options.selector,
        template: options.template || '',
        inputs: options.inputs,
        outputs: options.outputs || [],
        exportAs: options.exportAs || ''
    };
    class Mock {
    }
    metadata.outputs.forEach(method => {
        Mock.prototype[method] = new EventEmitter();
    });
    return Component(metadata)(Mock);
}
function MockDirectiveDeprecated(options) {
    const metadata = {
        selector: options.selector,
        inputs: options.inputs,
        outputs: options.outputs || [],
        exportAs: options.exportAs || ''
    };
    class Mock {
    }
    metadata.outputs.forEach(method => {
        Mock.prototype[method] = new EventEmitter();
    });
    return Directive(metadata)(Mock);
}

/// <reference path="./lib/matchers-types.ts" />

/**
 * Generated bundle index. Do not edit.
 */

export { ActivatedRouteStub, DOMSelector, HostComponent, HostModule, HttpMethod, MockComponentDeprecated, MockDirectiveDeprecated, Spectator, SpectatorDirective, SpectatorHost, SpectatorHttp, SpectatorPipe, SpectatorRouting, SpectatorService, byAltText, byLabel, byPlaceholder, byRole, byTestId, byText, byTextContent, byTitle, byValue, createComponentFactory, createDirectiveFactory, createFakeEvent, createHostFactory, createHttpFactory, createKeyboardEvent, createMouseEvent, createPipeFactory, createRoutingFactory, createServiceFactory, createSpyObject, createTouchEvent, defineGlobalsInjections, dispatchEvent, dispatchFakeEvent, dispatchKeyboardEvent, dispatchMouseEvent, dispatchTouchEvent, doesServiceImplementsOnDestroy, initialSpectatorDirectiveModule, initialSpectatorModule, initialSpectatorPipeModule, initialSpectatorWithHostModule, installProtoMethods, isHTMLOptionElementArray, isNumber, isObject, isString, isType, mockProvider, toBeChecked, toBeDisabled, toBeEmpty, toBeFocused, toBeHidden, toBeMatchedBy, toBeSelected, toBeVisible, toContainProperty, toContainText, toContainValue, toExist, toHaveAttribute, toHaveClass, toHaveData, toHaveDescendant, toHaveDescendantWithText, toHaveExactText, toHaveId, toHaveLength, toHaveProperty, toHaveSelectedOptions, toHaveStyle, toHaveText, toHaveValue, typeInElement, ɵ0$1 as ɵ0, ɵ1, ɵ10, ɵ11, ɵ12, ɵ13, ɵ14, ɵ15, ɵ16, ɵ17, ɵ18, ɵ19, ɵ2, ɵ20, ɵ21, ɵ22, ɵ23, ɵ24, ɵ25, ɵ26, ɵ27, ɵ28, ɵ3, ɵ4, ɵ5, ɵ6, ɵ7, ɵ8, ɵ9, DomSpectator as ɵa, BaseSpectator as ɵb };

//# sourceMappingURL=ngneat-spectator.js.map